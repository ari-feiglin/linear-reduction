\input pdfToolbox
\input preamble

\setlayout{horizontal margin=2cm, vertical margin=2cm}

{\setbox0=\hbox{\setfontandscale{bf}{25pt}Linear Reduction}
\centerline{
    \vbox{
        \copy0
        \smallskip
        \hbox to\wd0{\hfil Ari Feiglin and Noam Kaplinski}
    }
}}

\bigskip
\hbox to\hsize{\hfil\vbox{\hsize=.7\hsize
\leftskip=0pt plus 1fil \rightskip=\leftskip \parfillskip=\z@
\hrule
\kern5pt

In this paper we will define the concept of linear reduction in the context of syntax parsing.
We will progress through more and more complicated examples, beginning from the programming of a simple calculator until we ultimately have created an extensible programming language, which we call Lang-X.

\kern5pt
\hrule
}\hfil}

\section*{Table of Contents}

\tableofcontents

\vfill\break

\setcounter{section}{-1}
\section{Notation}

\benum
    \item ${\bb N}$ denotes the set of natural numbers, including $0$.
    \item $\overline{\bb N}$ is defined to be ${\bb N}\cup\set\infty$.
    \item ${\bb Z}$ denotes the set of integers.
    \item $\overline{\bb Z}$ is defined to be ${\bb Z}\cup\set{\pm\infty}$.
    \item $f\colon A\plongto B$ means that $f$ is a partial function from $A$ to $B$.
    \item If ${\sf X}$ is a set and ${\sf x}$ is some symbol, then ${\sf X}_{\sf x}={\sf X}^{\sf x}={\sf X}\cup\set{{\sf x}}$.
    \item $\epsilon$ is the empty string, it and $\varnothing$ are also used to denote ``nothing'' in whatever context that may be.
    \item $(x_1,\dots,x_n)$ denotes a list.
    \item If $\ell_1,\ell_2$ are lists, $\ell_1@\ell_2$ is their concatenation.
    \item $t{::}\ell$ is the list whose first element is $t$ and whose tail is $\ell$.
\eenum
\vfill\break

\section{The Algorithm}

\subsection{Stateless Reduction}

The idea of linear reduction is simple: given a string $\xi$ the first character looks if it can bind with the second character to produce a new character, and the process repeats itself.
There is of course, nuance.
This nuance hides in the statement ``if it can bind'': we must define the rules for binding.

Let us define an {\it reducer} to be a tuple $(\Sigma,\beta,\pi)$ where $\Sigma$ is an alphabet; $\beta\colon\overline\Sigma\times\overline\Sigma\plongto\overline\Sigma$ is a partial function called the
{\it reduction function} where $\overline\Sigma=\Sigma\times\overline{\bb N}$; and $\pi$ is the {\it initial priority function}.
A {\it program} over an reducer is a string over $\overline\Sigma$.
We write a program like $\sigma^1_{i_1}\cdots\sigma^n_{i_n}$ instead of as pairs $(\sigma^1,i_1)\dots(\sigma^n,i_n)$.
In the character $\sigma_i$, we call $i$ the {\it priority} of $\sigma$.

Then the rules of reduction are as follows, meaning we define $\beta(\xi)$ for a program:
We do so in cases:
\benum
    \item If $\xi=\sigma_i$ then $\beta(\xi)=\sigma_0$.
    \item If $\xi=\sigma^1_i\sigma^2_j\xi'$ where $i\geq j$ and $\beta(\sigma^1_i,\sigma^2_j)=\sigma^3_k$ is defined then $\beta(\xi)=\sigma^3_k\xi'$.
    \item Otherwise, for $\xi=\sigma^1_i\sigma^2_j\xi'$, $\beta(\xi)=\sigma^1_i\beta(\sigma^2_j\xi')$.
\eenum

A string $\xi$ such that $\beta(\xi)=\xi$ is called {\it irreducible}.
Notice that it is possible for a string of length more than $1$ to be irreducible: for example if $\beta(\sigma^1,\sigma^2)$ is not defined then $\sigma^1_i\sigma^2_j$ is irreducible.
$$ \beta(\sigma_1\tau_2)\xvarrightarrow{(3)}\sigma_1\beta(\tau_2)\xvarrightarrow{(1)}\sigma_1\tau_2 $$
But such strings are not desired, since in the end we'd like a string to give us a value.
So an irreducible string which is not a single character is called {\it ill-written}, and a string which is not ill-written is {\it well-written}.

Now the initial priority function is $\pi\colon\Sigma\plongto\overline{\bb N}$ which gives characters their initial priority.
We can then canonically extend this to a function $\pi\colon\Sigma^*\plongto(\Sigma\times\overline{\bb N})^*$ defined by $\pi(\sigma^1\cdots\sigma^n)=\sigma^1_{\pi(\sigma^1)}\cdots\sigma^n_{\pi(\sigma^n)}$.
Then a $\beta$-reduction of a string $\xi\in\Sigma^*$ is taken to mean a $\beta$-reduction of $\pi(\xi)$.

Notice that once again we require that $\pi$ only be a partial function.
This is since that we don't always need every character in $\Sigma$ to have an initial priority; some symbols are only given their priority through the $\beta$-reduction of another pair of symbols.
So we now provide a new definition of a {\it program}, which is a string $\xi=\sigma^1\cdots\sigma^n\in\Sigma^*$ such that $\pi(\sigma^i)$ exists for all $1\leq i\leq n$.
We can only of course discuss the reductions of programs, as $\pi(\xi)$ is only defined if $\xi$ is a program.

\Example let $\Sigma={\bb N}\cup\set{+,\cdot}\cup\set{(n+),(n\cdot)}[n\in{\bb N}]$.
$\beta$ as follows:

\medskip
\centerline{
    \vtop{\ialign{\hfil$#$\hfil\tabskip=.25cm&\hfil$#$\hfil\cr
        \sigma^1_i,\sigma^2_j & \beta(\sigma^1_i,\sigma^2_j)\cr\noalign{\kern3pt\hrule\kern3pt}
        n,+ & (n+)\cr
        n,\cdot & (n\cdot)\cr
        (n+),m & n+m\cr
        (n\cdot),m & n\cdot m\cr
        (n\cdot),(m+) & (n\cdot m,+)\cr
        (n+),(m+) & (n+m,+)\cr
        (n\cdot),(m\cdot) & (n\cdot m,\cdot)\cr
    }}
}
\medskip
\noindent Where $n,m$ range over all values in ${\bb N}$.
Here $\beta(\sigma_i,\sigma_j)$'s priority is $j$.
We define the initial priorities
$$ \pi(n) = \infty,\quad \pi(+) = 1,\quad \pi(\cdot) = 2 $$

Now let us look at the string $1+2\cdot3+4;$.
Here,
$$ \eqalign{
    1_\infty+_12_\infty\cdot_23_\infty+_14_\infty &\longto (1+)_12_\infty\cdot_23_\infty+_14_\infty\cr
    &\longto (1+)_1(2\cdot)_23_\infty+_14_\infty\cr
    &\longto(1+)_1(2\cdot)_2(3+)_14_\infty\cr
    &\longto(1+)_1(6+)_14_\infty\cr
    &\longto(7+)_14_\infty\cr
    &\longto(7+)_14_0\cr
    &\longto(11)_0
} $$
So the rules for $\beta$ we supplied seem to be sufficient for computing arithmetic expressions following the order of operations.
\qedd

\Example We can also expand our language to include parentheses.
So our alphabet becomes $\Sigma={\bb N}\cup\set{+,\cdot,(,)}\cup\set{\uline{ n+},\uline{ n\cdot},\uline{ n)}}[n\in{\bb N}]$.
We distinguish between parentheses and bold parentheses for readability.
We extend $\beta$ as follows:

\medskip
\centerline{
    \vtop{\ialign{\hfil$#$\hfil\tabskip=.25cm&\hfil$#$\hfil\cr
        \sigma^1_i,\sigma^2_j & \beta(\sigma^1_i,\sigma^2_j)\cr\noalign{\kern3pt\hrule\kern3pt}
        n,+ & \uline{ n+}_j\cr
        n,\cdot & \uline{ n\cdot}_j\cr
        \uline{ n+},m & (n+m)_j\cr
        \uline{ n\cdot},m & (n\cdot m)_j\cr
        \uline{ n\cdot},\uline{ m+} & \uline{ n\cdot m,+}_j\cr
        \uline{ n+},\uline{ m+} & \uline{ n+m,+}_j\cr
        \uline{ n\cdot},\uline{ m\cdot} & \uline{ n\cdot m,\cdot}_j\cr
        n,) & \uline{ n)}_j\cr
        \uline{ n+},\uline{ m)} & \uline{ n+m)}_j\cr
        \uline{ n\cdot},\uline{ m)} & \uline{ n\cdot m)}_j\cr
        (,\uline{ n)} & n_i\cr
    }}
}
\medskip

\noindent $(n+m)_j$ means $n+m$ with a priority of $j$, not $\uline{ n+m}_j$.
And we define the initial priorities
$$ \pi(n) = \infty,\quad \pi(+) = 1,\quad \pi(\cdot) = 2,\quad \pi({(}) = \infty,\quad \pi({)}) = 0 $$
So for example reducing $2\cdot((1+2)\cdot2)+1$,
$$ \eqalign{
    2_\infty*_2{(_\infty}{(_\infty}1_\infty+_12_\infty{)_0}*_22_\infty{)_0}+_11_\infty &\longto \uline{2*}_2{(_\infty}{(_\infty}1_\infty+_12_\infty{)_0}*_22_\infty{)_0}+_11_\infty\cr
    &\longto \uline{2*}_2{(_\infty}{(_\infty}\uline{1+}_12_\infty{)_0}*_22_\infty{)_0}+_11_\infty\cr
    &\longto \uline{2*}_2{(_\infty}{(_\infty}\uline{1+}_1\uline{2)}_0*_22_\infty{)_0}+_11_\infty\cr
    &\longto \uline{2*}_2{(_\infty}{(_\infty}\uline{3)}_0*_22_\infty{)_0}+_11_\infty\cr
    &\longto \uline{2*}_2{(_\infty}3_\infty*_22_\infty{)_0}+_11_\infty\cr
    &\longto \uline{2*}_2{(_\infty}\uline{3*}_22_\infty{)_0}+_11_\infty\cr
    &\longto \uline{2*}_2{(_\infty}\uline{3*}_2\uline{2)}_0+_11_\infty\cr
    &\longto \uline{2*}_2{(_\infty}\uline{6)}_0+_11_\infty\cr
    &\longto \uline{2*}_26_\infty+_11_\infty\cr
    &\longto \uline{2*}_2\uline{6+}_11_\infty\cr
    &\longto \uline{12+}_11_\infty\cr
    &\longto \uline{12+}_11_0\cr
    &\longto 13_0\cr
} $$
\qedd

\subsection{Stateful Reduction}

\noindent We define the following four base sets:
\benum
    \item ${\cal U}$ the universe of {\it values}, these are all the internal values an object may have.
    \item $\term_{\cal P}$ the set of {\it printable terms}, these are the tokens which a programmer may pass to the reducer.
    \item $\term_{\type}$ the set of {\it type terms}.
    \item $\term_{\cal A}$ the set of {\it abstract terms}.
\eenum
The sets $\term_{\cal P},\term_\type,\term_{\cal A}$ are all disjoint, we place no such restriction on ${\cal U}$ as the purpose it serves is different.
Let ${\cal A}$ be a set of {\it atomic abstract terms}, then the construction of abstract terms is
$$ \term_{\cal A} \ccoloneqq {\cal A}\mid{\cal A}\term_\type $$
And let $\type$ be a set of {\it atomic types}, each with an associated arity, which may be $\infty$.
Let $\type^n$ be the set of atomic types of arity $n$, then the construction of type terms is
$$ \term_\type \ccoloneqq \type^0 \mid \type^n\term_\type^1\cdots\term_\type^n\mid\type^\infty\term_\type^1\cdots\term_\type^n $$
as $n$ ranges over all ${\bb N}_{>0}$.

Define
\benum
    \item $\term\coloneqq\term_{\cal P}\cup\term_\type\cup\term_{\cal A}$ the set of {\it basic terms}.
    \item $\term_{\cal I}\coloneqq\term_\type\cup\term_{\cal A}$ the set of {\it internal terms}.
    \item $\Pi_{\cal I}\coloneqq\term_{\cal I}\times{\cal U}$ the set of {\it termed values}.
    \item $\Pi\coloneqq\Pi_{\cal I}\cup\term_{\cal P}$ the set of {\it atomic expressions}.
\eenum
Elements of $\overline\Pi$ will be written like $\sigma_n(v)$ where $\sigma$ is the term, $n$ the priority, and $v$ the value (nothing for printable terms).

We define the {\it initial priority function} as a function $\pi\colon\term_{\cal P}\longto\overline{\bb Z}$.
This can be extended canonically to a function $\pi\colon\term_{\cal P}^*\longto\overline{\Pi}^*$.

In stateful reduction, we abstract away some inputs to the initial beta-reducer in order to allow for easier implementation.
An initial beta-reducer is a partial function
$$ \varwidehat\beta\colon \term_{\cal I}\times\term^\epsilon\plongto\term_{\cal I}^\epsilon\times(\overline{\bb Z}\times\overline{\bb Z}\to\overline{\bb Z})\times
({\cal U}\times{\cal U}\times{\rm State}\pto{\cal U}\times\term_{\cal P}^*\times{\rm State}) $$

We extend this to a derived $\beta$-reducer,
$$ \beta\colon\overline\Pi^*\times{\rm State}\plongto\overline\Pi^*\times{\rm State} $$
We also define $\beta^*$ where given an input $\gen{\xi}[s]$, it runs $\beta$ on it iteratively until convergence (of $\xi$).
$\beta$ is defined with the following rules: given an input $\gen{\xi}[s]$ its image is
\benum
    \item If $\xi=\sigma_n\xi'$ for $\sigma\in\term_{\cal P}$ then
        $$ \beta\gen{\xi}[s] = \gen{s(\sigma)_n\xi'}[s] . $$
    \item If $\xi=\sigma_i(v)\xi'$ and $\hat\beta(\sigma,\epsilon)=(\alpha,\rho,f)$ is defined, then if $f(v,\_,s)=(w,\zeta,s')$ and $\rho(i)=k$ and $\beta^*\gen{\pi\zeta}[s']=\gen{\zeta'}[s'']$ then
        $$ \beta\gen{\xi}[s] = \gen{\alpha_k(w)\zeta'\xi'}[s''] . $$
    \item If $\xi=\sigma_i(v)\tau_j(u)\xi'$ and $i\geq j$ and $\hat\beta(\sigma,\tau)=(\alpha,\rho,f)$ is defined, then if $f(v,u,s)=(w,\zeta,s')$, $\rho(i,j)=k$, and
        $\beta^*\gen{\pi\zeta}[s']=\gen{\zeta'}[s'']$ then
        $$ \beta\gen{\xi}[s] = \gen{\alpha_k(w)\zeta'\xi'}[s''] . $$
    \item Otherwise, if $\xi=\sigma_i(v)\xi'$ and $\beta\gen{\xi'}[s]=\gen{\xi''}[s']$,
        $$ \beta\gen{\xi}[s] = \gen{\sigma_i(v)\xi''}[s'] . $$
\eenum

\subsubsection{States}

Similar to before, we define point-states as partial maps $\term_{\cal P}\plongto\Pi_{\cal I}$.
And if $s_1,s_2$ are two point-states and $\sigma\in\term_{\cal P}$ then
$$ s_1s_2(\sigma) = \cases{s_2(\sigma) & $\sigma\in{\rm dom}s_2$\cr s_1(\sigma) & $\sigma\in{\rm dom}s_1$} $$
We will denote finite point states as $[\sigma_1\mapsto\varkappa_1,\dots,\sigma_n\mapsto\varkappa_n]$, and this denotes the point-state which maps $\sigma_i$ to $\varkappa_i$.

A state will now have two fields: a sequence of point-states, as well as a sequence of indexes.
For a state $\bar s=\bigl[(s_1,\dots,s_n),I=(i_1,\dots,i_k)\bigr]$, let us define
\benum
    \item $\bar s+s=\bigl[(s_1,\dots,s_n,s),I\bigr]$
    \item $\bar s+_cs=\bigl[(s_1,\dots,s_n,s),(i_1,\dots,i_k,n+1)\bigr]$
    \item $\pop\bar s=\bigl[(s_1,\dots,s_{n-1}),I\bigr]$ if $i_k<n$ otherwise, $\bigl[(s_1,\dots,s_{n-1}),(i_1,\dots,i_{k-1})\bigr]$
    \item $\bar ss=\bigl[(s_1,\dots,s_ns),I\bigr]$
    \item $\bar s(\sigma)=s_1\cdots s_n(\sigma)$ for $\sigma\in\Sigma_P$
    \item $\bar s_c=s_{i_k}\cdots s_n$
\eenum
Furthermore, if $\sigma\in\term_{\cal P}$ and $\varkappa\in\Pi_{\cal I}$ let us define $\bar s\{\sigma\mapsto\varkappa\}$ as $(s_1,\dots,s_i[\sigma\mapsto\varkappa],\dots,s_n)$ where $i$ is the maximum
index such that $\sigma\in{\rm dom}s_i$.

\vfill\break

\section{The Grammar}

In this section we discuss the grammar of the language of Lang-X.
This is not naturally imposed by the parser, but it will properly parse programs of this form.

\medskip
\grammar
\noalign{\hbox{\bf Identifiers}}
    str&\ccoloneqq\(a\dots z\gbar A\dots Z\gbar\_\)\cr
    digit&\ccoloneqq\(0\dots9\)\cr
    ident&\ccoloneqq{\sl str}\ \({\sl str}\gbar{\sl digit}\)^*\cr
\noalign{\hbox{\bf Constant Expressions}}
    const&\ccoloneqq\({\sl number}\gbar{\sl product}\gbar{\sl list}\)\cr
    number&\ccoloneqq\({\sl digit}\)^*[.\({\sl digit}\)^*]\cr
    product&\coloneqq({\sl production}\ \(,{\sl production}\)^*)\cr
    production&\coloneqq\({\sl expr}\gbar{\sl product}\)\cr
\noalign{\hbox{\bf Expressions}}
    op&\ccoloneqq+\gbar*\gbar/\cr
    pop&\ccoloneqq-\cr
    expr&\ccoloneqq\hphantom{{}\gbar}{\sl ident}\cr
    &\bbar{\sl const}\cr
    &\bbar{\sl expr};\cr
    &\bbar{\sl expr}\ {\sl expr}\cr
    &\bbar{\sl primexpr}\cr
    &\bbar({\sl expr})\cr
    &\bbar{\sl expr}\ \({\sl op}\gbar{\sl pop}\)\ {\sl expr}\cr
    &\bbar{\sl pop}\ {\sl expr}\cr
    &\bbar{\sl expr}.{\sl expr}\cr
    &\bbar{\bf if}\ ({\sl expr})\ \{{\sl expr}\} \{{\sl expr}\}\cr
    &\bbar{\bf fun}\ {\sl ident}\ ({\sl pattern})\ \{{\sl expr}\}\cr
    primexpr&\ccoloneqq\hbox{\bf\_prim\_}{\sl ident}\cr
\egrammar

\vfill\break

\section{Initializing the Algorithm}

\subsection{The Initial Beta Reducer}

We now describe the initial beta reducer of Lang-X according to stateful reduction.
By convention, {\astyle atomic abstract terms} will be red, {\tstyle type terms} will be green, {\istyle internal terms} will be blue.

\noindent{\bf End}:
\blist
    \item $\isig\ \eend \longto \isig\ \minfty\ (u,\_,s\to u,\epsilon,s)$
\elist

\noindent{\bf Arithmetic}:
\blist
    \item $\tsig\ \op \longto \op\tsig\ \snd\ (u,f,s\to(u,f),\epsilon,s)$
    \item $\op\tsig\ \op\tsig \longto \op\tsig\ \snd\ \bigl((u,f),(v,g),s\to (f(u,v),g),\epsilon,s\bigr)$
    \item $\op\tsig\ \tsig \longto \tsig\ \snd\ \bigl((u,f),v,s\to f(u,v),\epsilon,s\bigr)$
    \item $\Pop\ \tsig \longto \tsig\ \snd\ \bigl((f,g),u,s\to f(u),\epsilon,s\bigr)$
    \item $\tsig\ \Pop \longto \op\tsig\ {\sf one}\ \bigl(u,(f,g),s\to(u,g),\epsilon,s\bigr)$
    \item $\tsig\ \rparen \longto \rparen\tsig\ \snd\ (u,\_,s\to u,\epsilon,s)$
    \item $\op\tsig\ \rparen\tsig \longto \rparen\tsig\ \snd\ \bigl((f,u),v,s\to f(u,v),\epsilon,s\bigr)$
    \item $\Pop\ \rparen\tsig \longto \rparen\tsig\ \snd\ \bigl((f,g),u,s\to f(u),\epsilon,s\bigr)$
    \item $\lparen\ \rparen\tsig \longto \tsig\ \fst\ (\_,u,s\to u,\epsilon,s)$
\elist

\noindent{\bf Lists}:
\blist
    \item $\lbrack\ \tsig \longto \lbrack\tsig\ \fst\ (\_,u,s\to (u),\epsilon,s)$
    \item $\lbrack\tsig\ \tsig \longto \lbrack\tsig\ \fst\ (\ell,u,s\to (\ell,u),\epsilon,s)$
    \item $\lbrack\tsig\ \rbrack \longto \list\tsig\ \pinfty\ (\ell,\_,s\to\ell,\epsilon,s)$
    \item $\period\ \num \longto \index\ \zero\ (\_,n,s\to n,\epsilon,s)$
    \item $\list\tsig\ \index \longto \tsig\ \fst\ (\ell,i,s\to \ell_i,\epsilon,s)$
\elist

\noindent{\bf Variables}:
\blist
    \item $\lett\ x \longto \letvar\ \snd\ (\_,\_,s\to(x,\varnothing),\epsilon,s)$
    \item $\letvar\ \index \longto \letvar\ \fst\ \bigl((x,\ell),n,s\to(x,(\ell,n)),\epsilon,s\bigr)$
    \item $\letvar\ \equal \longto \leteq\ \minfty\ \bigl((x,\ell),\_,s\to(x,\ell),\epsilon,s\bigr)$
    \item $\leteq\ \isig \longto \epsilon\ \varnothing\ \bigl((x,\ell),v,s\to\epsilon,\epsilon,s'\bigr)$ where $s'$ is $s[x\varmapsto\sigma(v)]$ if $\ell=\varnothing$ and otherwise let $t$ be the result of
        setting $s(x).\ell_1.\dots.\ell_n$ to $v$, then $s'=s[x\varmapsto t]$.
\elist

\noindent{\bf Scoping}:
\blist
    \item $\lbrace\ \epsilon \longto \epsilon\ \varnothing\ (\_,\_,s\to\epsilon,\epsilon,s+\varnothing)$
    \item $\rbrace\ \epsilon \longto \epsilon\ \varnothing\ (\_,\_,s\to\epsilon,\epsilon,\pop s)$
\elist

\noindent{\bf Products}:
\blist
    \item $\tsig\ \comma \longto \comma(\tsig)\ \snd\ (u,\_,s\to(u),\epsilon,s)$
    \item $\op\tsig\ \comma(\tsig) \longto \comma(\tsig)\ \snd\ ((f,u),(v)\to (f(u,v)),\epsilon,s)$
    \item $\Pop\ \comma(\tsig) \longto \comma(\tsig)\ \snd\ ((f,g),(u)\to (f(u),\epsilon,s))$
    \item $\comma\tOmeg\ \comma(\tsig) \longto \comma(\tOmeg,\tsig)\ \snd\ (\ell,\ell',s\to(\ell,\ell'),\epsilon,s)$
    \item $\comma\tOmeg\ \rparen\tsig \longto \listrparen(\tOmeg,\tsig)\ \snd\ (\ell,v\to (\ell,v),\epsilon,s)$
    \item $\lparen\ \listrparen\tOmeg \longto \product\tOmeg\ \pinfty\ (\_,\ell,s\to \ell,\epsilon,s)$
\elist

\noindent{\bf Primitives}:
\blist
    \item $\primitive\ \isig \longto \epsilon\ \varnothing\ (f,v,s\to \epsilon,w,s)$ where $f(\isig,v)=(w,s')$ (the purpose is for $f$ to have a side effect)
\elist

\noindent{\bf Code Capture}
\blist
    \item $\lbrace\a\ x\longto \lbrace\a\ \pinfty\ (\xi,\_,s\to\xi x,\epsilon,s)$ if $x\neq\{,\}$
    \item $\lbrace\a\ x\longto \code\ \pinfty\ (\xi,\_,s\to\xi,\epsilon,s)$
    \item $\lbrace\a\ \code\longto \lbrace\a\ \pinfty\ (\xi,\xi',s\to\xi\{\xi'\},\epsilon,s)$
\elist

\noindent{\bf Parameter Capture}
\blist
    \item $\lparen\a\ x \longto \lparen\a\ \fst\ (\ell,\_,s\to \ell @(x),\epsilon,s)$ for $x\neq(,)$
    \item $\lparen\a\ ) \longto \plist\ \fst\ (\ell,\_,s\to \ell,\epsilon,s)$
    \item $\lparen\a\ \plist \longto \lparen\a\ \fst\ (\ell,\ell',s\to (\ell @(\ell')),\epsilon,s)$
\elist

\noindent{\bf Function Definitions}
\blist
    \item $\fun\ x\longto \funname\ \pinfty\ (\_,\_,s\to(x,\epsilon), \epsilon, s + [\{\mapsto\lbrace\a,\}\mapsto\rbrace\a,(\mapsto\lparen\a,)\mapsto\rparen\a])$
    \item $\funname\ \plist \longto \funvars\ \pinfty\ \bigl((x,\epsilon),u,s \to (x,u),\epsilon,s\bigr)$
    \item $\funvars\ \code \longto \closure\ \fst\ \bigl((x,\ell),\xi,s\to C=\gen{\ell,\xi,s'[x\mapsto\closure(C)]},\epsilon,\pop s[x\mapsto\closure(C)]\bigr)$ where $s'=(\pop s)_c$.
\elist

\noindent{\bf Function Calls}
\blist
    \item $\closure\ \tsig \longto \epsilon\ \varnothing\ \bigl(\gen{\ell,\xi,{\it ps}},u,s\mapsto\epsilon,\xi\},s+_c{\it ps}[\ell\mapsto\tsig(u)]\bigr)$ where $\ell\mapsto\tsig(u)$ means that if
        $\ell=(x)$ then $x\mapsto \tsig(u)$.
        Otherwise $\ell=(x_1,\dots,x_n)$, $\tsig=\product\tsig_1\cdots\tsig_n$, and $u=(u_1,\dots,u_n)$ and $x_i\mapsto\tsig_i(u_i)$ (recursively).
\elist

\noindent{\bf If Statements}
\blist
    \item $\iif\ \tsig \longto \ifbool\ \fst\ (\_,n,s\to n,\epsilon,s+[\{\mapsto\lbrace\a,(\mapsto\lparen\a)]$
    \item $\ifbool\ \code \longto \ifthen\ \fst\ (n,\xi,s\to(n,\xi),\epsilon,s)$
    \item $\ifthen\ \code \longto \epsilon\ \_\ ((n,\xi_1),\xi_2,s\to\varnothing,(n=0?\ \xi_2:\xi_1),\pop s)$
\elist

\noindent{\bf Types}
\blist
    \item $\tp\tsig\ \tp\ttau \longto \tp\tsig(\ttau)\ \snd\ (\_,\_,s\to \tsig(\ttau),\epsilon,s)$
    \item $\tp\tsig\ \product(\tp\ttau_1,\dots,\tp\ttau_n) \longto \tp\tsig(\ttau_1,\dots,\ttau_n)\ \snd\ (\_,\_,s\to \tsig(\ttau_1,\dots,\ttau_n),\epsilon,s)$
    \item $\ccolon\ \tp\tsig \longto \typer\tsig\ \snd\ (\_,u,s\to u,\epsilon,s)$
    \item $\tsig\ \typer\ttau \longto \ttau\ \snd\ (u,\_,s\to u,\epsilon,s)$
\elist

\subsection{The Initial State}

The initial state is a partial state, defined as follows:

\bigskip

\hbox{\vtop{\hsize=.48\hsize
\noindent{\bf End}
\blist
    \item $;{}\mapsto(\eend,\varnothing)$
\elist

\noindent{\bf Arithmetic}
\blist
    \item $({}\mapsto(\lparen,\varnothing)$
    \item $){}\mapsto(\rparen,\varnothing)$
    \item $+{}\mapsto(\op, (n,m\to n+m))$
    \item $+{}\mapsto(\op, (n,m\to n+m))$
    \item $*{}\mapsto(\op, (n,m\to n*m))$
    \item $/{}\mapsto(\op, (n,m\to n/m))$
    \item $-{}\mapsto(\Pop, (n\to-n), (n,m\to n-m))$
    \item $@{}\mapsto(\op, (\ell_1,\ell_2\to\ell_1@\ell_2))$
    \item $!={}\mapsto(\op,(u,v\to u\neq v))$
    \item $<={}\mapsto(\op,(n,m\to n\leq m))$
    \item $>={}\mapsto(\op,(n,m\to n\geq m))$
    \item $=={}\mapsto(\op,(u,v\to u=v))$
\elist
}\hfil
\vtop{\hsize=.48\hsize
\blist
    \item $<{}\mapsto(\op,(n,m\to n<m))$
    \item $>{}\mapsto(\op,(n,m\to n>m))$
\elist

\noindent{\bf Lists}
\blist
    \item $[{}\mapsto(\lbrack,[])$
    \item $]{}\mapsto(\rbrack,\varnothing)$
    \item $.\mapsto(\period,\varnothing)$
\elist

\noindent{\bf Variables}
\blist
    \item ${\rm let}\mapsto(\lett,\varnothing)$
    \item $={}\mapsto(\equal,\varnothing)$
\elist

\noindent{\bf Scoping}
\blist
    \item $\{{}\mapsto(\lbrace,\varnothing)$
    \item $\}{}\mapsto(\rbrace,\varnothing)$
\elist

\noindent{\bf Products}
\blist
    \item $,{}\mapsto(\comma,\varnothing)$
\elist

}}
\vfill\break

\hbox{\vtop{\hsize=.48\hsize
\noindent{\bf Primitives}
\blist
    \item ${\rm\_prim\_print}\mapsto$
        \hfil\break\null\hfill$(\primitive,(a,v\to{\rm print}(v); (\varnothing,\varnothing)))$
    \item ${\rm\_prim\_len}\mapsto(\primitive,(a,\ell\to\num,\abs\ell))$
    \item ${\rm\_prim\_tail}\mapsto(\primitive,(\tsig,t::\ell\to\tsig,\ell))$
    \item ${\rm\_prim\_type}\mapsto(\primitive,(\tsig,\_\to\tp\tsig,\tsig))$
\elist

\noindent{\bf Keywords}
\blist
    \item ${\rm fun}\mapsto(\fun,\varnothing)$
    \item ${\rm if}\mapsto(\iif,\varnothing)$
\elist
}
\vtop{\hsize=.48\hsize
\noindent{\bf Types}
\blist
    \item $:{}\mapsto(\colon,\varnothing)$
    \item ${\rm Num}\mapsto(\tp\ \num,\num)$
    \item ${\rm List}\mapsto(\tp\ \list,\list)$
    \item ${\rm Closure}\mapsto(\tp\ \closure,\closure)$
    \item ${\rm Product}\mapsto(\tp\ \product,\product)$
    \item ${\rm Primitive}\mapsto(\tp\ \primitive,\primitive)$
    \item ${\rm Type}\mapsto(\tp\ \tp, \tp)$
\elist
}}

\subsection{The Initial Priorities}

The initial priority function, $\pi$, is defined as follows:

\bigskip
\hbox{\vtop{\hsize=.48\hsize
\noindent{\bf End}
\blist
    \item $;{}\mapsto-\infty$
\elist

\noindent{\bf Arithmetic}
\blist
    \item $({}\mapsto\infty$
    \item $){}\mapsto0$
    \item $+{}\mapsto1$
    \item $*{}\mapsto2$
    \item $-{}\mapsto1$
    \item $/{}\mapsto2$
    \item $@{}\mapsto1$
    \item $=={}\mapsto0$
    \item $!={}\mapsto0$
    \item $<={}\mapsto0$
    \item $>={}\mapsto0$
    \item $<{}\mapsto0$
    \item $>{}\mapsto0$
\elist
}
\vtop{\hsize=.48\hsize
\noindent{\bf Lists}
\blist
    \item $[{}\mapsto0$
    \item $]{}\mapsto0$
    \item $.{}\mapsto0$
\elist

\noindent{\bf Variables}
\blist
    \item $={}\mapsto-\infty$
\elist

\noindent{\bf Scoping}
\blist
    \item $\{{}\mapsto0$
    \item $\}{}\mapsto0$
\elist

\noindent{\bf Products}
\blist
    \item $,{}\mapsto0$
\elist

\noindent Everything else is mapped to $\infty$
}}

\vfill\break

\section{Proving Equivalence}

In this section we will prove that our algorithm interprets according to the proper order of operations.
Specifically we will define a natural method of parsing and interpreting a numerical expression, and show that given a valid expression our algorithm gives the same result.

The problem can be formulated as follows: we are given the following:
\benum
    \item A set $\s X$, which is our {\it universe}.
    \item A set $\s S$ of {\it operator symbols}.
    \item For every operator symbol $\s s\in\s S$, a function $f_{\s s}\colon\s X\times\s X\longto\s X$.
    \item For every operator symbol $\s s\in\s S$, a {\it priority} $\pi(\s s)\in{\bb N}$.
\eenum
We define the following grammar of {\it expressions}:
$$ {\sl expr} \ccoloneqq ({\sl expr}) \gbar {\sl expr}\ \s S\ {\sl expr} \gbar \s X $$
\def\unparen{\hbox{\tencsc unparen}}%
All operators are left-associative.
We define $\unparen(\xi,i)$ to mean that the $i$th character in $\xi$ is not within parentheses (this can be implemented easily: iterate backwards and count how many opening and closing parentheses there
are.
If there are more opening than closing, than it is inside parentheses.)
We now define the evaluator for expressions:

\def\eval{\hbox{\tencsc eval}}
\algorithm
\Function{eval}{$\xi$}
    \If{$\xi=\s x\in\s X$}
        \State\Return $\s x$
    \ElseIf{$\xi[0]=$`('}
        \State $\xi$ is of the form $(\rho)\xi'$
        \State\Return $\eval(\eval(\rho)\xi')$
    \Else
        \Comment Find the greatest index with the smallest operator.\cr
        Note that $\max_i{\rm argmin}_if(i)$ is the maximal $i$ which minimizes $f$.\EndComment
        \State $i\coloneqq\max_i{\rm argmin}_i\set{\pi(\xi[i])}[{\xi[i]\in\s S,\unparen(\xi,i)}]$
        \State $\s s\coloneqq\xi[i]$
        \Comment $\xi'=\xi[:i-1]$, $\xi''=\xi[i+1:]$ \EndComment
        \State $\xi$ is of the form $\xi'\s s\xi''$
        \State\Return $f_{\s s}(\eval(\xi'),\eval(\xi''))$
    \EndIf
\EndFunc
\ealgorithm

For our beta reducer, our type term will be $\s X$, the atomic abstract terms will be $\s S,\Lparen,\Rparen$, and printable terms will be elements of $\s X\cup\s S$.
We will define the following initial beta reducer, we ignore states and printable term outputs because they are held constant:
\blist
    \item $\s X\ \s S\longto\s S\s X\ \snd\ (u,f\to(u,f))$
    \item $\s S\s X\ \s S\s X \longto\s S\s X\ \snd\ ((u,f),(v,g)\to(f(u,v),g))$
    \item $\s S\s X\ \s X\longto\s X\ \snd\ ((u,f),v\to f(u,v))$
    \item $\s X\ \Rparen \longto \Rparen\s X\ \snd\ (u,\_\to u)$
    \item $\s S\s X\ \Rparen\s X \longto\Rparen\s X\ \snd\ ((u,f),v\to f(u,v))$
    \item $\Lparen\ \Rparen\s X \longto\s X\ \snd\ (\_,u\to u)$
\elist
\noindent The initial state is self-explanatory.
The initial priorities map $\s x\in\s X$ to $\infty$, $\s s\in\s S$ to $\pi(\s s)$, $($ to $\infty$, and $)$ to $0$.
Since the state never changes, we can assume that all tokens are given their value in the initial state from the outset.

Let $\beta^*$ be the total $\beta$-reducer: it iteratively applies $\beta$ until convergence
We also define $\beta_0$ and $\beta^*_0$ which include the rule that if $\xi$ is a single character $\sigma_n(u)$ then $\beta_0\xi=\sigma_0(u)$.
We write $\xi\tos\xi'$ to mean that successive applications of $\beta_0$ lead from $\xi$ to $\xi'$.

Let us define the following set of {\it reduced expressions}, as a grammar including priorities:
$$ {\sl rexpr} \ccoloneqq \s X_n\gbar \s S\s X_n\ {\sl rexpr}\gbar \s X_n\ \s S_m\ {\sl rexpr}\ (n\geq m) $$
Say that a string of internal terms $S$ is {\it closed under $\beta$-reductions} if for every string $\xi\in S$ with arbitrary priorities, $\beta\gen\xi\in S$.

\lemm
    ${\sl rexpr}$ is closed under $\beta$-reductions.
    And under $\beta_0$-reductions, every reduced expression converges to an element in $\s X$.
\elemm

\Proof We induct on the length of the string $\xi$.
We split into cases
\benum
    \item A string of the form $\s X_n$ retains its value under a $\beta$-reduction.
    \item For string of the form $\s S\s X_n\xi$, we have the following cases:
        \benum
            \item $\xi=\s X_m$, if $n\geq m$ this becomes $\s X_m\in{\sl rexpr}$.
                Otherwise, a $\beta$-reduction gives $\s S\s X_n\beta\gen{\s X_m}=\s S\s X_n\s X_m\in{\sl rexpr}$.
            \item $\xi=\s S\s X_m\xi'$, if $n\geq m$ then this becomes $\s S\s X_m\xi'\in{\sl rexpr}$.
                Otherwise, a $\beta$-reduction gives $\s S\s X_n\beta\gen{\xi}$, and $\beta\gen{\xi}\in{\sl rexpr}$ inductively.
            \item $\xi=\s X_m\ \s S_k\xi'$, if $n\geq m$ then this becomes $\s X_m\ \s S_k\xi'\in{\sl rexpr}$.
                Otherwise, a $\beta$-reduction gives $\s S\s X_n\beta\gen{\xi}\in{\sl rexpr}$ inductively.
        \eenum
    \item For a string of the form $\s X_n\s S_m\xi$, if $n\geq m$ then a $\beta$-reduction gives $\s S\s X_m\xi\in{\sl rexpr}$.
        Otherwise we get $\s X_n\beta\gen{\s S_m\xi}$, but there are no reduction rules in which $\s S$ is the first term, so this is just $\s X_n\s S_m\gen\xi\in{\sl rexpr}$ inductively.
\eenum

For the second claim, we inductively show that if $\xi\neq\s X$ has a final priority of $0$ then a $\beta_0$ reduction will decrease its length by $1$, and if its final priority is $>0$ then it either
decreases its length by $1$ or sets its final priority to $0$.
\benum
    \item If $\xi=\s S\s X_n\xi'$, then a $\beta_0$-reduction either compounds $\s S\s X_n$ with another token, or gives $\s S\s X_n\beta_0\gen{\xi'}$, which inductively will decrease $\xi'$'s length by $1$
        if $\xi'$'s final priority is zero, or will decrease it by a token or set its final priority to zero otherwise.
    \item If $\xi=\s X_n\ \s S_m\xi'$, since $n\geq m$ then this reduces to $\s S\s X_m\xi'$, which is one token less.
\eenum
So this means that every two $\beta_0$-reductions (in fact every single $\beta_0$-reduction, since we can never increase a priority: once a token's priority is $0$, it will never increase) will decrease
the length of the string.
This means that eventually the string will converge to a single token.
Since ${\sl rexpr}$ is closed under $\beta_0$-reductions, this string must be in $\s X$.
\qed

Note that ${\sl expr}\subseteq{\sl rexpr}$ since ${\sl expr}\ccoloneqq\s X_\infty\gbar\s S_n\ \s X_\infty\ {\sl expr}$.
So when $\beta$-reducing an expression, we will remain inside ${\sl rexpr}$.

Notice that if $\xi\in{\sl rexpr}$ then $\beta^*\gen\xi$ cannot contain a substring of the form $\s X_n\ \s S_m$ since this can be reduced.
And since by the above lemma, $\beta^*\gen\xi\in{\sl rexpr}$, we have $\beta^*\gen\xi=\s S\s X_{n_1}\s S\s X_{n_2}\cdots\s S\s X_{n_k}\s X_{n_{k+1}}$ with $n_1<\cdots<n_k<n_{k+1}$.

Instead of writing
\blist
    \item $\s X_n(\s x)$, we write $\s x_n$.
    \item $\s S_n(f_{\s s})$, we write $\s s_n$.
    \item $\s S\s X_n(\s x,f_{\s s})$, we write $\s s_n[\s x]$.
\elist

We begin with the case that $\xi$ does not include any parentheses.
Let us define $\pi(\xi)=\set{\pi(\xi[i])}_{0\leq i<\abs\xi}$.

\lemm
    Let $\xi\in{\sl rexpr}$ such that $\pi(\xi)\geq n$, then $\beta^*\gen{\xi\s s_n}=\s s_n[\beta^*_0\gen\xi]$.
\elemm

\Proof we know that $\xi\s s_n$ is reduced to, at some point, $\beta^*\gen\xi\s s_n$, and as noted this is equal to
$$ \s s_{n_1}^1[\s x^1]\cdots\s s^k_{n_k}[\s x^k]\s x^{k+1}_{n_{k+1}}\s s_n,\qquad n\leq n_1<\cdots<n_k<n_{k+1} $$
Then a $\beta$-reduction gives
$$ \s s^1_{n_1}[\s x^1]\cdots\s s^k_{n_k}[\s x^k]\s s_n[\s x^{k+1}] $$
and further $\beta$-reductions give (instead $f_{\s s_i}$ we'll write $f_i$):
$$ \s s^1_{n_1}[\s x^1]\cdots\s s_n[f_k(\s x^k,\s x^{k+1})] \to \cdots \to \s s_n\bigl[f_1(\s x^1,f_2(\s x^2,\cdots))\bigr] $$
And we see that $\beta_0$-reducing $\xi$ gives precisely $f_1(\s x^1,f_2(\s x^2,\cdots))$, as required.
\qed

\lemm
    If $\xi\in{\sl rexpr}$ and $n<\pi(\xi)$ then $\beta^*_0\gen{\s s_n[\s x]\xi}=f_{\s s}(\s x,\beta^*_0\gen\xi)$.
\elemm

\Proof since $n<\pi(\xi)$, $\s s_n[\s x]$ cannot reduce with the first element of $\xi$, so $\beta_0\gen{\s s_n[\s x]\xi}=\s s_n[\s x]\beta_0\gen\xi$.
If $\xi$ can be $\beta$-reduced, then we simply induct on the new string, which is one token less.
Otherwise $\xi=\s s^1_{n_1}[\s x^1]\cdots\s s^k_{n_k}[\s x^k]\s x_{n_{k+1}}^{k+1}$ with $n_1<\cdots<n_{k+1}$, as remarked before.
Then we continue with a similar process as before.
\qed

Let $\xi\in{\sl expr}$, define ${\rm sym}(\xi)$ be the operator symbols in $\xi$.
By {\it inducting on the levels of priority}: we mean induction on $\pi{\rm sym}(\xi)$.

\thrm
    Let $\xi\in{\sl expr}$, then $\beta^*_0\gen\xi=\hbox{\tencsc eval}(\xi)$.
\ethrm

\Proof we induct on the levels of priority in $\xi$.
If $\xi=\s x_n$ then this is trivial.
Otherwise let $n$ be the lowest priority of operator in $\xi$, so $\xi$ is of the form
$$ \xi = \xi_1\s s_n^1\xi_2\s s_n^2\cdots\xi_k\s s_n^k\xi_{k+1} $$
Now notice that
$$ \xi \to \beta^*\gen{\xi_1\s s_n^1\xi_2\cdots\xi_k\s s_n^k}\xi_{k+1} $$
by lemma 4.0.2 this is equal to
$$ \xi \to \s s_n^k[\beta^*_0\gen{\xi_1\s s_n^1\cdots\s s_n^{k-1}\xi_k}]\xi_{k+1} $$
and by lemma 4.0.3 reducing this gives
$$ f_k\bigl(\beta^*_0\gen{\xi_1\s s^1_n\cdots\s s^k_n\xi_k},\beta^*_0\gen{\xi_{k+1}}\bigr) $$
Continuing inductively on $k$, we get
$$ f_k\bigl(\cdots f_2(f_1(\beta^*_0\gen{\xi_1},\beta^*_0\gen{\xi_2}),\beta^*_0\gen{\xi_3})\cdots,\beta^*_0\gen{\xi_{k+1}}\bigr) $$
By induction, this is just
$$ f_k\bigl(\cdots f_2(f_1(\eval(\xi_1),\eval(\xi_2)),\eval(\xi_3))\cdots,\eval(\xi_{k+1})\bigr) \eqnum[bsres] $$
Now notice that
$$ \eval(\xi) = f_k(\eval(\xi_1\s s_n^1\cdots\s s_n^{k-1}\xi_k),\eval(\xi_{k+1})) $$
And continuing we get that this is equal to $(\bsres)$, as required.
\qed

\bye

