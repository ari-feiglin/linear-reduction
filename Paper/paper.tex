\documentclass{llncs}

%\usepackage[margin=1in]{geometry}
\usepackage{amsmath, amssymb, mathtools}
\usepackage{enumitem}
\usepackage{float}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{mdframed}
%\usepackage{cleveref}

\def\labelitemi{$\bullet$}
\def\labelenumi{(\textbf{\arabic{enumi}})}

\usepackage{tikz}
\usetikzlibrary{trees}

\newcounter{algo}

\floatstyle{ruled}
\newfloat{algo}{h}{aux}
\floatname{algo}{Algorithm}

\input preamble

\newcommand{\yoni}[1]{{\begin{mdframed}[linecolor=red]{\color{red}#1}\end{mdframed}}}
\newcommand{\ari}[1]{{\begin{mdframed}[linecolor=blue]{\color{blue}#1}\end{mdframed}}}
\begin{document}

\title{Iterative Reduction: Parsing and Interpreting Code Without Trees}
\author{Ari Feiglin\inst{1}\and Yoni Zohar\inst{1}}
\institute{Bar-Ilan University, Ramat Gan, Israel}

\maketitle

\begin{abstract}
    In this paper we discuss an alternative method to parsing and interpreting human-readable code.
    This method utilizes an iterative approach, as opposed to a recursive tree-oriented approach found in most modern compilers and interpreters.
    We implement our algorithm in an interpreter and compare it with an interpreter created using more classical means.

    \keywords{Parsing \and Interpreting \and AST \and Parse Trees}

\end{abstract}

\section{Introduction}
Nowadays, most programming language interpreters follow the following pipeline (see \cite{dragon})
\begin{enumerate}
    \item Lexing: lexically analyze the input code, separating it into atomic \textit{tokens}.
    \item Parsing: convert the parsed tokens into a \textit{parse tree}: a tree which represents the code according to the language's grammar.
    \item Interpreting: recursively descend the tree and execute the code according to the instructions embedded in the tree.
\end{enumerate}
For example, we can parse the following expression:

\centerline{\texttt{1 + 2 * 3 + 4}}

\noindent as follows

\medskip
\centerline{\begin{tikzpicture}
\node{\texttt{+}}
child {node {\texttt{1}}}
child {node {\texttt{+}}
    child {node {\texttt{*}}
        child {node {\texttt{2}}}
        child {node {\texttt{3}}}
    }
    child {node {\texttt{4}}}
};
\end{tikzpicture}}
\medskip

One can then descend the parse tree and compute the expression.
Explicitly, if you reach a node whose operator is $\circ$, evaluate the left tree to get $x$, evaluate the right tree to get $y$, and then return $x\circ y$.

Unfortunately, constructing such a tree is not so easy.
Multiple methods for doing so exist (some are listed in \cite{dragon}), as well as tools for automating this process.

We propose a novel method for the process of interpretation, which doesn't use parse trees.
But our algorithm is not limited to this, and can be altered to produce parse trees as well (see $\S$\ref{producing-parse-trees}).
This means that our algorithm can be utilized as part of the pipeline for compilers and traditional interpreters.

The idea of the algorithm is as follows: the input is a stream of tokens, which are indivisible characters in any language.
Given a string of tokens $\mb{\sigma^1}\cdots\mb{\sigma^n}$ (for readability, tokens are written in boxes), we form rules for combining two tokens.
For example, $\mb{\ttt1}$ and $\mb{\ttt+}$ can be combined together to give a token $\mb{\ttt{1,+}}$.
Then if we follow a token of the form $\mb{\ttt{x,+}}$ with a token of the form $\mb{\ttt y}$, the tokens are combined to form a token $\mb{\ttt{x+y}}$.
So for example:
\[ \mbt{1} \mbt{+} \mbt{2} \mbt{+} \mbt{3} \to \mbt{1,+} \mbt2 \mbt+ \mbt3 \to \mbt{3} \mbt+ \mbt3 \to \mbt{3,+} \mbt3 \to \mbt6 \]
But what about \ttt{1+2*3}?
We'd get
\[ \mbt1 \mbt+ \mbt2 \mbt* \mbt3 \to \mbt{1,+} \mbt2 \mbt* \mbt3 \to \mbt3 \mbt* \mbt3 \to \mbt{3,*} \mbt3 \to \mbt9 \]

So to remedy this we add the concept of \textit{priorities}: for each token in our alphabet $\Sigma$, we assign a priority $p\in\bbN$.
This can be thought of as a \textit{priority function} $\pi\colon\Sigma\longto\bbN$.
So if the tokens $\mb{\sigma^1}\cdots\mb{\sigma^n}$ have respective priorities $p_1,\dots,p_n$ we can form the string $\mb{\sigma^1}_{p_1}\cdots\mb{\sigma^n}_{p_n}$ (where the subscript is part of the
character).
Now, we only combine two tokens if the token of the first is at least as great as the token of the second, and then the combined token gets the lower (the second) of the two priorities.
So we can assign to tokens containing numbers a priority of $\infty$, the token \ttt+ gets a priority of $1$, and $\ttt*$ gets a priority of $2$.
Then this becomes:
\[ \mbt1_\infty \mbt+_1 \mbt2_\infty \mbt*_2 \mbt3_\infty \to \mbt{1,+}_1 \mbt2_\infty \mbt*_2 \mbt3_\infty \to \mbt{1,+}_1 \mbt{2,*}_2 \mbt3_\infty \]
This cannot be combined any further, so we need another rule: we give the final token a priority of $0$, so this becomes:
\[ \mbt{1,+}_1 \mbt{2,*}_2 \mbt3_0 \to \mbt{1,+}_1 \mbt{6}_0 \to \mbt{7}_0 \]
which is the correct result.

\section{Notation}

\begin{enumerate}
    \item $\bN$ denotes the set of natural numbers, including $0$.
    \item $\bbN$ is defined to be $\bN\cup\set{+\infty}$.
    \item $\bZ$ denotes the set of integer numbers.
    \item $\bbZ$ is defined to be $\bZ\cup\set{\pm\infty}$.
    \item $f\colon A\partial B$ means that $f$ is a partial function from $A$ to $B$ (i.e. $\operatorname{dom}f\subseteq A$).
    \item $\epsilon$ denotes the empty string.
    \item If $\mathcal L$ is a language (a set of strings), then $\mathcal L^\epsilon$ is equal to $\mathcal L\cup\set\epsilon$.
    \item A list is denoted by $(x_1,\dots,x_n)$.
    \item The concatenation of two lists $\ell_1$ and $\ell_2$ is denoted by $\ell_1@\ell_2$.
    \item $x::\ell$ is the list whose first element is $x$ and tail is $\ell$.
\end{enumerate}

\section{The Algorithm}

\subsection{A First Attempt -- Primitive Reduction} \label{sec:firstattempt}

We can formalize the algorithm given in the introduction as follows: we start with an alphabet of tokens $\Sigma$.
Define $\oS=\Sigma\times\bbN$, and we assume the existence of a so-called \textit{initial $\beta$-reducer}:
$\hb\colon \Sigma\times\Sigma \longto \Sigma$, which is defined by the implementer of the language being interpreted, and is the function which
tells us how to combine tokens together.
We extend it to a \textit{derived $\beta$-reducer} which is a function $\beta\colon\oS^*\longto\oS^*$ as follows.

Suppose $\xi=\sigma^1_{p_1}\cdots\sigma^n_{p_n}$, then $\beta(\xi)$ is defined recursively as follows:
\begin{enumerate}
    \item if $n=1$, then $\beta(\xi)=\sigma^n_0$,
    \item if $p_1\geq p_2$, then $\beta(\xi)=\hb(\sigma^1,\sigma^2)_{p_2}\sigma^3_{p_3}\cdots\sigma^n_{p_n}$,
    \item otherwise $\beta(\xi)=\sigma^1_{p_1}\,\beta(\sigma^2_{p_2}\cdots\sigma^n_{p_n})$.
\end{enumerate}

To assign priorities to an input stream of tokens, we assume the existence of a \textit{priority function} $\pi\colon\Sigma\partial\bbN$.
We can then extend this to a function $\pi\colon\Sigma^*\longto\oS^*$ by $\pi(\sigma^1\cdots\sigma^n)=\sigma^1_{\rho_1}\cdots\sigma^n_{\rho_n}$ where $\rho_i=\pi(\sigma^i)$.
Notice that not every token is assigned an initial priority; such tokens thus cannot be in the initial input stream to the $\beta$-reduction.

% Notice that since in our reduction we get pairs of tokens in the form $\mbt{x,*},\mbt{y,+}$, we need to add extra rules to handle these cases.
% Specifically here we have $\hb(\mbt{x,*},\mbt{y,+})=\mbt{x*y,+}$.


\begin{example}

    Define $\Sigma$ to consist of tokens of the form $\mbt{x}$ for every $x\in\mathbb{N}$, $\mb\circ$ for $\circ\in\{+,*\}$, and $\mbt{x,$\circ$}$ for every $x\in\mathbb{N}$
    and $\circ\in\{+,*\}$.
    
    Then we define the initial $\beta$-reducer $\hb$ by
    \begin{enumerate}
        \item $\hb(\mbt x,\mb\circ)=\mbt{x,$\circ$}$ for $\circ\in\{+,*\}$
        \item $\hb(\mbt{x,$\circ$},\mbt y)=\mbt{x$\circ$y}$ for 
        $x,y\in\mathbb{N}$ and $\circ\in\{+,*\}$
        \item $\hb(\mbt{x,$\circ$},\mbt{y,$\bullet$})=\mbt{x$\circ$y,$\bullet$}$ 
        for $x,y\in\mathbb{N}$ and $\circ,\bullet\in\{+,*\}$
        \item $\hb$ is defined arbitrarily on any other input.
    \end{enumerate}
    
    We also define the initial priority function to give numbers a priority of $\infty$, and operations a priority corresponding to their precedence in the order of operations,
    where smaller priorities have less precedence.
    Namely, we give $+$ a priority of $1$ and $*$ a priority of $2$.
    
    Now, consider the expression $1*2+3$. 
    After assigning priorities, we obtain the following expression:
    $\mbt1_\infty \mbt*_2 \mbt2_\infty \mbt+_1 \mbt3_\infty$.
    We now get:
    \begin{multline*}
        \mbt1_\infty \mbt*_2 \mbt2_\infty \mbt+_1 \mbt3_\infty \to \mbt{1,*}_2 \mbt2_\infty \mbt+_1 \mbt3_\infty \to \mbt{1,*}_2 \mbt{2,+}_1 \mbt3_\infty \to \mbt{2,+}_1 \mbt3_\infty\\
        \to \mbt{2,+}_1 \mbt3_0 \to \mbt5_0
    \end{multline*}

\end{example}

But this has a major issue: it can't handle things like parentheses.
We could of course handle parentheses by changing how we assign priorities: every time we see an open parentheses we could increase
the priority of each token and then beta-reduce.
But this complicates how we allocate priorities, as we can no longer statically assign priorities using a simple priority function $\pi$ but must instead design a more complicated algorithm in order
to allow for generalization.
Furthermore the notion introduced in the next section, partial reduction, generalizes well and is used as a basepoint in the
remainder of this paper.

\subsection{A Second Attempt -- Partial Reduction}

In order to handle parentheses, all we need to do is to make a simple change to our algorithm.
Instead of a full function which also tells us how to compute the new priority, the initial $\beta$-reducer will be a partial function:
\[ \hb\colon \Sigma\times\Sigma\partial\Sigma\times(\bbZ\times\bbZ\to\bbZ) \]
We add a function to compute the new priority of the token to the output of the initial $\beta$-reducer instead of taking the priorities as inputs.
This is because the new token computed should not be dependent on the priorities of the input tokens, as this just adds extra unnecessary
complexity.

Now we define the derived $\beta$-reducer as follows; it is a function $\beta\colon\oS^*\partial\oS^*$ where for $\xi=\sigma^1_{p_1}\cdots\sigma^n_{p_n}$:
\begin{enumerate}
    \item if $n=1$ then $\beta(\xi)=\sigma^n_0$,
    \item if $p_1\geq p_2$ and $\hb(\sigma^1,\sigma^2)=(\tau,\rho)$ is defined, then $\beta(\xi)=\tau_{\rho(p_1,p_2)}\sigma^3_{p_3}\cdots\sigma^n_{p_n}$,
    \item otherwise $\beta(\xi)=\sigma^1_{p_1}\,\beta(\sigma^2_{p_2}\cdots\sigma^n_{p_n})$.
\end{enumerate}

\begin{example}

    We define our alphabet $\Sigma$ to be the same as in~\ref{sec:firstattempt}.
    Now we define our initial $\beta$-reducer which will support parentheses.
    It is an extension of our previous $\beta$-reducer:
    \begin{gather*}
        \hb(\mbt x,\mb\circ) = (\mb{\ttt x,\circ},\snd),\quad \hb(\mb{\ttt x,\circ},\mbt y) = (\mb{\ttt x\circ\ttt y},\snd) \qquad \hbox{for $\circ\in\set{\ttt{+,*}}$} \\
        \hb(\mbt{x,*},\mbt{y,+}) = (\mbt{x*y,+},\snd)
    \end{gather*}
    where $\fst,\snd$ are the first and second projections, respectively (i.e. $(x,y)\mapsto x$ and $(x,y)\mapsto y$).
    We then add the rules for parentheses:
    \begin{gather*}
        \hb(\mbt x,\mbt)) = (\mbt{x,)},\snd),\quad \hb{\mb{\ttt x,\circ},\mbt{y,)}} = (\mb{\ttt x\circ\ttt y,\ttt)},\snd) \qquad \hbox{for $\circ\in\set{\ttt{+,*}}$} \\
        \hb(\mbt(,\mbt{x,)}) = (\mbt x,\fst)
    \end{gather*}
    \gobble) % syntax highlighting
    And we define our priority function as follows:
    \yoni{feels out of context, the notion of a priority function
    was not defined. Also, notice that some tokens get priorities and some don't, which is a bit confusing.}
    \ari{Both points are now explained in the previous section, is this good?}
    \[ \pi(\mbt x) = \infty\hbox{ for numbers \ttt x},\quad \pi(\mbt+) = 1,\quad \pi(\mbt*) = 2,\quad \pi(\mbt() = \infty,\quad \pi(\mbt)) = 0 \]
    
    Now take for example \ttt{2*(1+3)+4}:
    \begin{align*}
        \mbt2_\oo \mbt*_2 \mbt(_\oo \mbt1_\oo \mbt+_1 \mbt3_\oo \mbt)_0 \mbt+_1 \mbt4_\oo &\to \mbt{2,*}_2 \mbt(_\oo \mbt1_\oo \mbt+_1 \mbt3_\oo \mbt)_0 \mbt+_1 \mbt4_\oo\\
            &\to \mbt{2,*}_2 \mbt(_\oo \mbt{1,+}_1 \mbt3_\oo \mbt)_0\mbt+_1 \mbt4_\oo\\
            &\to \mbt{2,*}_2 \mbt(_\oo \mbt{1,+}_1 \mbt{3,)}_0 \mbt+_1 \mbt4_\oo\\
            &\to \mbt{2,*}_2 \mbt(_\oo \mbt{4,)}_0 \mbt+_1 \mbt4_\oo\\
            &\to \mbt{2,*}_2 \mbt4_\oo \mbt+_1 \mbt4_\oo\\
            &\to \mbt{2,*}_2 \mbt{4,+}_1 \mbt4_\oo\\
            &\to \mbt{8,+}_1 \mbt4_\oo\\
            &\to \mbt{8,+}_1 \mbt4_0\\
            &\to \mbt{12}_0
    \end{align*}
    \gobble)\gobble)

\end{example}

Notice that our $\beta$-reducers don't care about the exact value of the number and operation: both $\mbt1\mbt+$ and $\mbt2\mbt*$ are mapped to something of the form $\mbt{x,$\circ$}$.
We can thus abstract away the exact value of tokens and have our initial $\beta$-reducer deal only with the form of the token.
We do such in our third attempt.

\subsection{A Third Attempt -- Valued Reduction} \label{valued-reduction}

Here we abstract away the value of each term; the value of the new term given by the initial $\beta$-reducer will be determined by an output function.
Our alphabet of tokens $\Sigma$, instead of having a token for every number, will just have tokens for types (number, operator, etc.).
We also have another set $\values$, the \textit{universe of values}.

\yoni{I would consider using the word "kinds" instead of "types". "kinds" is not great either, but types are stuff like int, real, int->int, which i am not sure is appropriate here.}
\ari{I understand this, I'm not such a fan of ``kinds'' but I guess using ``types'' isn't really faithful to its understanding in CS.
I'd like to maybe discuss this with you more when we meet.}

The initial $\beta$-reducer is a function
\[ \hb \colon \Sigma\times\Sigma \partial \Sigma\times(\bbZ\times\bbZ\to\bbZ)\times(\values\times\values\partial\values) \]
Define $\oP=\oS\times\values$ to be the set of all possible terms,
that is, 
a term consists of a type, a priority, and a value.
Since terms now consist of three parts, we write them as $\sigma_p(v)$, where $\sigma$ is the type; $p$ is the priority; and $v$ the value.

Our rules for the derived $\beta$-reducer are similar to before: it is a function $\beta\colon\oP^* \partial \oP^*$ where for $\xi=\sigma^1_{p_1}(v_1)\cdots\sigma^n_{p_n}(v_n)$
\begin{enumerate}
    \item if $n=1$ then $\beta(\xi)=\sigma^n_0(v_n)$,
    \item if $p_1\geq p_2$ and $\hb(\sigma^1,\sigma^2)=(\tau,\rho,f)$ is defined, then
    \[ \beta(\xi)=\tau_{\rho(p_1,p_2)}(f(v_1,v_2))\sigma^3_{p_3}(v_3)\cdots\sigma^n_{p_n}(v_n) \]
    \item otherwise $\beta(\xi)=\sigma^1_{p_1}(v_1)\beta(\sigma^2_{p_2}(v_2)\cdots\sigma^n_{p_n}(v_n))$.
\end{enumerate}


\begin{example}

    Define $\Sigma=\set{\NUM,\OP,\LPAREN,\RPAREN,\OP\NUM,\RPAREN\NUM}$.
    Our initial $\beta$-reducer will is defined as follows:
    \begin{itemize}
        \item $\hb(\NUM,\OP)=(\OP\NUM,\snd,(v,f\mapsto(v,f))$
        \item $\hb(\OP\NUM,\NUM)=(\NUM,\snd,((v,f),u\mapsto f(v,u)))$
        \item $\hb(\OP\NUM,\OP\NUM)=(\OP\NUM,\snd,((v,f),(u,g)\mapsto (f(v,u),g))$
        \item $\hb(\NUM,\RPAREN)=(\RPAREN\NUM,\snd,(v,\_\mapsto v))$
        \item $\hb(\OP\NUM,\RPAREN\NUM)=(\RPAREN\NUM,\snd,((v,f),u\mapsto f(v,u)))$
        \item $\hb(\LPAREN,\RPAREN\NUM)=(\NUM,\fst,(\_,v\mapsto v))$
    \end{itemize}
    In the first point $(v,f\mapsto(v,f))$ means that the function to compute the value of the new token is one which takes two values $v,f$ and outputs a new value which is the pair $(v,f)$.
    
    So taking our previous example of \ttt{2*(1+3)+4}: we first must convert it into tokens acceptable for $\beta$-reduction (via lexing).
    In this example allocating initial priorities is not so simple: the priorities depend not on the type of the token in $\Sigma$, but the token in the stream given to the lexer.
    So we will assume the lexer allocates priorities similar to the previous example in the previous section.
    This issue will be resolved in the next section.
    So the stream is converted to
    \[ \NUM_\infty(2)\ \OP_2(*)\ \LPAREN_\infty\ \NUM_\infty(1)\ \OP_1(+)\ \NUM_\infty(3)\ \RPAREN_0\ \OP_1(+)\ \NUM_\infty(4) \]
    We no longer need boxes to distinguish between tokens because the individual tokens and so we will no longer use them.

    The derivation is then
    \begin{gather*}
        \OP\NUM_2(2,*)\ \LPAREN_\infty\ \NUM_\infty(1)\ \OP_1(+)\ \NUM_\infty(3)\ \RPAREN_0\ \OP_1(+)\ \NUM_\infty(4) \\
        \OP\NUM_2(2,*)\ \LPAREN_\infty\ \OP\NUM_1(1,+)\ \NUM_\infty(3)\ \RPAREN_0\ \OP_1(+)\ \NUM_\infty(4) \\
        \OP\NUM_2(2,*)\ \LPAREN_\infty\ \OP\NUM_1(1,+)\ \RPAREN\NUM_0(3)\ \OP_1(+)\ \NUM_\infty(4) \\
        \OP\NUM_2(2,*)\ \LPAREN_\infty\ \RPAREN\NUM_0(4)\ \OP_1(+)\ \NUM_\infty(4) \\
        \OP\NUM_2(2,*)\ \NUM_\infty(4)\ \OP_1(+)\ \NUM_\infty(4) \\
        \OP\NUM_2(2,*)\ \OP\NUM_1(4,+)\ \NUM_\infty(4) \\
        \OP\NUM_2(8,+)\ \NUM_\infty(4) \\
        \OP\NUM_2(8,+)\ \NUM_0(4) \\
        \NUM_0(12)
    \end{gather*}

\end{example}
But this of course is not capable of handling the semantics necessary for programming languages.
We need a notion of a state, and a somewhat more refined algorithm.

\subsection{A Fourth Attempt -- Stateful Reduction}

We define the following four base sets:
\begin{enumerate}
    \item $\values$ the \textit{universe of values}; these are all the internal values an object may have.
    \item $\termp$ the set of \textit{printable terms}; this is the set of all printable tokens a programmer may type.
    \item $\terms$ the set of \textit{type terms}; these are terms which correspond to types in the classical sense.
    \item $\terma$ the set of \textit{abstract terms}; these are intermediate terms (like $\OP\NUM$ from the previous section).
\end{enumerate}
The sets $\termp,\terms,\terma$ must be disjoint, and we place no such restriction on $\values$ (it can include elements from $\termp,\terms,\terma$).
\yoni{The comment about no restrictions for $\values$ is unclear.}

While we don't need to place any further restrictions on $\termp,\terms,\terma$, we found it useful to explicitly construct them.
To construct $\terms$, we begin with a set of \textit{base types} $\Sigma$.
Each base type has an associated arity in $\bbN$; let $\Sigma^n$ denote the set of all base types of arity $n$.
Then we define $\terms$ inductively as follows:
\begin{enumerate}
    \item for $\sigma\in\Sigma^0$; $\sigma$ is a type term.
    \item for $\sigma\in\Sigma^n$ for $n>0$, and $\tau_1,\dots,\tau_n$ type term; $\sigma\tau_1\cdots\tau_n$ is a type term.
    \item finally for $\sigma\in\Sigma^\infty$ and any $n\geq0$, if $\tau_1,\dots,\tau_n$ are type terms so is $\sigma(\tau_1\cdots\tau_n)$.
\end{enumerate}
We can write this definition as:
\[ \terms \ccoloneqq \Sigma^0 \mid \Sigma^1\terms \mid \Sigma^2\terms\terms \mid \Sigma^3\terms\terms\terms \mid \cdots \mid \Sigma^\oo(\terms\cdots\terms) \]

To construct $\terma$ we start with $\mathcal A$, a set of \textit{atomic abstract terms}, again each with an arity in $\bbN$.
$\mathcal A^n$ is the set of atomic abstract terms of a set arity $n$.
Then $\terma$ is defined as follows:
\begin{enumerate}
    \item for $\sigma\in\c A^0$; $\sigma$ is an abstract term.
    \item for $\sigma\in\c A^n$ for $n>0$, and $\tau_1,\dots,\tau_n\in\terms^\epsilon$; $\sigma(\tau_1,\dots,\tau_n)$ is an abstract term.
        When writing such an abstract term, we may omit parentheses and commas if there is no confusion.
    \item for $\sigma\in\c A^\infty$ and any $n\geq0$, for $\tau_1,\dots,\tau_n\in\terms^\epsilon$; $\sigma(\tau_1,\dots,\tau_n)$ is an abstract term.
\end{enumerate}
Alternatively:
\[ \terma \ccoloneqq \mathcal A^0\mid\mathcal A^1\terms^\epsilon\mid\mathcal A^2\terms^\epsilon\terms^\epsilon\mid\mathcal A^3\terms^\epsilon\terms^\epsilon\terms^\epsilon\mid\cdots\mid
\mathcal A^\infty\terms^\epsilon\cdots\terms^\epsilon \]
Here we allow parameters to atomic abstract terms to be empty (i.e. $\terms^\epsilon$ instead of just $\terms$).

For readability we can put and omit parentheses and commas where convenient, but importantly these sets have the \textit{unique reconstruction property}:
it is possible to compute their construction from the string itself (i.e. a string cannot be constructed from two different patterns).
This property is not hard to prove.

\begin{example}

    If $\Sigma^{0}=\{\NUM\}$, $\Sigma^{1}=\{\LIST\}$, and $\Sigma^{\infty}=\{\PRODUCT\}$, and $\Sigma=\Sigma^0\cup\Sigma^1\cup\Sigma^\infty$, and $\c A=\mathcal A^1=\set{\OP}$, 
    then
    \[ \NUM,\LIST\ \NUM,\PRODUCT(\LIST\ \NUM\ \NUM)\in\terms,\qquad \OP\ \LIST\ \NUM\in\terma \]

\end{example}

Now we define the following sets:
\begin{enumerate}
    \item $\term=\termp\cup\terms\cup\terma$, the set of \textit{terms},
    \item $\termi=\terms\cup\terma$, the set of \textit{internal terms},
    \item $\expi=\termi\times\values$, the set of \textit{internal expressions},
    \item $\exp=\expi\cup\termp$, the set of \textit{expressions}.
\end{enumerate}
Finally we define $\oe=\exp\times\bbZ$.
Elements of $\oe$ will be written like $\sigma_n(v)$ as before: $\sigma$ is the term (printable or internal), $n$ the priority, and $v$ the value.
In the case that $\sigma$ is a printable term, we still use this notation even though the value does not exist: so we just take it to be empty.

The \textit{initial priority function} is a function $\pi\colon\termp\longto\bbZ$.
This can be naturally extended to $\pi\colon\termp^*\longto\oe^*$ as before: $\pi(\sigma^1\cdots\sigma^n)=\sigma^1_{\rho_1}\cdots\sigma^n_{\rho_n}$ where $\rho_i=\pi(\sigma^i)$.

Finally, our \textit{initial $\beta$-reducer} is a function ($\state$ is a set of functions $\termp\partial\expi$ which we define later)
\yoni{Using something and defining it later should be avoided...}
\ari{We can move the definition up, but I felt like it messed with the flow.}

\yoni{Generally, this section is hard to follow. I suggest adding plenty of examples, after every new definition / concept, please add an appropriate small example.}
\ari{I'm not really sure what kinds of examples to add; I added a big example at the end that we can potentially split up?
But I feel like we need all of the definitions to give a good example.}

\[ \hb\colon\termi\times\term^\epsilon \partial \termi^\epsilon\times(\bbZ\times\bbZ\to\bbZ)\times(\values\times\values\times\state\partial\values\times\termp^*\times\state) \]
and we extend this to a \textit{derived $\beta$-reducer}, a function
\[ \beta\colon\oe^*\times\state \partial \oe^*\times\state \]
inputs in $\oe^*\times\state$ will be written as $\gen\xi[\bar s]$ for $\xi\in\oe^*$ and $\bar s\in\state$.
We define $\beta^*\gen\xi[\bar s]$ to be the value obtained by composing $\beta$ with itself of $\gen\xi[\bar s]$ until the convergence of $\xi$.
Meaning
\begin{multline*}
    \beta^* = \beta^n\gen\xi[\bar s]\\
    \hbox{where $n=\min\set{n\geq1}[{\beta^n\gen\xi[\bar s]=\gen{\xi'}[\bar s'],\beta\gen{\xi'}[\bar s']=\gen{\xi'}[\bar s'']}]$}
\end{multline*}
We define $\beta\gen\xi[\bar s]$ as follows, where $\xi=\sigma^1_{p_1}(v_1)\cdots\sigma^n_{p_n}(v_n)$.
\begin{enumerate}
    \item if $\sigma^1\in\termp$ then
    \[ \beta\gen\xi[\bar s] = \gen{s(\sigma^1)_{p_1}\sigma^2_{p_2}(v_2)\cdots\sigma^n_{p_n}(v_n)}[\bar s] \]
    \item if $\hb(\sigma^1,\epsilon)=(\tau,\rho,f)$ is defined, then compute $f(v_1,\_,s)=(u,\xi',s')$ and $\beta^*\gen{\pi\xi'}[\bar s']=\gen{\xi''}[\bar s'']$, and
    \[ \beta\gen\xi[\bar s] = \gen{\tau_{\rho(p_1,\_)}\xi''\sigma^2_{p_2}(v_2)\cdots\sigma^n_{p_n}(v_n)}[\bar s''] \]
    \item if $p_1\geq p_2$ and $\hb(\sigma^1,\sigma^2)=(\tau,\rho,f)$ is defined, then compute $f(v_1,v_2,s)=(u,\xi',s')$ and $\beta^*\gen{\pi\xi'}[\bar s']=\gen{\xi''}[\bar s'']$, and
    \[ \beta\gen\xi[\bar s] = \gen{\tau_{\rho(p_1,p_2)}\xi''\sigma^3_{p_3}(v_2)\cdots\sigma^n_{p_n}(v_n)}[\bar s''] \]
    \item otherwise compute $\beta\gen{\sigma^2_{p_2}(v_2)\cdots\sigma^n_{p_n}(v_n)}[\bar s]=\gen{\xi'}[\bar s']$ and
    \[ \beta\gen\xi[\bar s] = \gen{\sigma^1_{p_1}(v_1)\xi'}[\bar s'] \]
\end{enumerate}

\subsubsection{States}

We begin by defining \textit{point-states} to be partial maps $\termp\partial\expi$.
If $s_1,s_2$ are two point-states then we define their composition to be
\[ s_1s_2(\sigma) = \begin{cases} s_2(\sigma) & \sigma\in\dom s_2\\ s_1(\sigma) & \sigma\in\dom s_1-\dom s_2\end{cases} \]
Point-states with finite domain will be denoted by $[\sigma_i\mapsto\varkappa_i]_{i=1}^n$ where $\sigma_1,\dots,\sigma_n$ is the domain and $\varkappa_1,\dots,\varkappa_n$ are their respective images.

A \textit{state} will be a pair of a sequence of point-states and a set of indices.
This will be denoted by $\bar s=[(s_1,\dots,s_n),\;I=(i_1,\dots,i_k)]$ (we require that $k\leq n$).
We define
\begin{enumerate}
    \item $\bar s+s=\bigl[(s_1,\dots,s_n,s),\;I\bigr]$, for $s$ a point-state,
    \item $\bar s+_cs=\bigl[(s_1,\dots,s_n,s),\;(i_1,\dots,i_k,n+1)\bigr]$, for $s$ a point-state,
    \item $\pop\bar s=\bigl[(s_1,\dots,s_{n-1}),\;I\bigr]$ if $i_k<n$, otherwise it is defined to be equal to $\bigl[(s_1,\dots,s_{n-1}),\;(i_1,\dots,i_{k-1})\bigr]$,
    \item $\bar ss=\bigl[(s_1,\dots,s_{n-1},s_ns),\;I\bigr]$ for $s$ a point-state,
    \item $\bar s(\sigma)=s_1\cdots s_n(\sigma)$ for $\sigma\in\termp$,
    \item $\bar s_c=s_{i_k}\cdots s_n$,
    \item if $\sigma\in\termp$ and $\varkappa\in\expi$ then $\bar s\{\sigma\mapsto\varkappa\}=\bigl[(s_1,\dots,s_k[\sigma\mapsto\varkappa],\dots,s_n),\;I\bigr]$ where $k$ is the maximum index such that
    $\sigma\in\dom s_k$.
\end{enumerate}

\ari{Adding the following example:}

\begin{example}

    Let $\Sigma^0=\set\NUM$, $\Sigma^1=\set\LIST$, $\Sigma=\Sigma^0\cup\Sigma^1$; and finally we have $\c A^0=\set{\COLON,\LBRACK,\RBRACK}$, $\c A^1=\set\OP$, $\c A=\c A^0\cup\c A^1$.
    Let our set of printable terms consists of numbers as well as $\set{\mbt+,\mbt*,\mbt;,\mbt[,\mbt]}$.
    For readability, we again return to putting boxes around printable terms (but only \textit{printable} terms).
    Our initial priority function is
    \[ \pi(\mbt n) = \infty,\ \pi(\mbt+) = 1,\ \pi(\mbt*) = 2,\ \pi(\mbt;) = 0,\ \pi(\mbt[) = 0,\ \pi(\mbt]) = 0 \]
    We can transform the following stream \ttt{[1 + 2; 3 * 4;]} (which should be interpreted as the list $(3,12)$) into the stream of expressions:
    \[ \mbt[_0\ \mbt1_\infty\ \mbt+_1\ \mbt2_\infty\ \mbt;_0\ \mbt3_\infty\ \mbt*_2\ \mbt4_\infty\ \mbt;_0\ \mbt]_0 \]

    Our initial state will map numbers $\mbt n$ to $\NUM(n)$; operations $\mbt{$\circ$}$ to $\OP(\circ)$; $\mbt;$ to $\COLON$; $\mbt[$ to $\LBRACK$; and $\mbt]$ to $\RBRACK$.

    Our initial $\beta$-reducer is defined as follows: (we will neglect the input state and output state and string in the output of the $\beta$-reducer as they are held constant and empty, respectively.
    That is, instead of $\hb(\dots)=(\dots,(v,u,\bar s\mapsto\dots,\epsilon,\bar s))$ we will just write $\hb(\dots)=(\dots,(v,u\mapsto\dots))$.)
    \begin{itemize}
        \item $\hb(\NUM,\OP)=(\OP\NUM,\snd,(v,f,\mapsto(v,f)))$
        \item $\hb(\OP\NUM,\NUM)=(\NUM,\snd,((v,f),u,\bar s\mapsto f(v,u)))$
        \item $\hb(\OP\NUM,\OP\NUM)=(\OP\NUM,\snd,((v,f),(u,g)\mapsto (f(v,u),g)))$
        \item $\hb(\sigma,\COLON)=(\sigma,\zero,(v,\_\mapsto v))$
        \item $\hb(\LBRACK,\sigma)=(\LBRACK\sigma,\fst,(\_,v\mapsto(v)))$
        \item $\hb(\LBRACK\sigma,\sigma)=(\LBRACK\sigma,\fst,(\ell,v\mapsto\ell::(v)))$
        \item $\hb(\LBRACK\sigma,\RBRACK)=(\LIST\sigma,\pinfty,(\ell,\_\mapsto\ell))$
    \end{itemize}

    We now begin the $\beta$-reduction: 
    \ialign to\hsize{\rlap{$#$}\tabskip=0pt plus 1fil&$\to#$\hfil\tabskip=\z@\cr
    \mbt[_0\ \mbt1_\infty\ \mbt+_1\ \mbt2_\infty\ \mbt;_0\ \mbt3_\infty\ \mbt*_2\ \mbt4_\infty\ \mbt;_0\ \mbt]_0\cr
        &\LBRACK_0\ \mbt1_\infty\ \mbt+_1\ \mbt2_\infty\ \mbt;_0\ \mbt3_\infty\ \mbt*_2\ \mbt4_\infty\ \mbt;_0\ \mbt]_0\cr
        &\LBRACK_0\ \NUM_\infty(1)\ \mbt+_1\ \mbt2_\infty\ \mbt;_0\ \mbt3_\infty\ \mbt*_2\ \mbt4_\infty\ \mbt;_0\ \mbt]_0\cr
        &\LBRACK_0\ \NUM_\infty(1)\ \OP_1(+)\ \mbt2_\infty\ \mbt;_0\ \mbt3_\infty\ \mbt*_2\ \mbt4_\infty\ \mbt;_0\ \mbt]_0\cr
        &\LBRACK_0\ \OP\NUM_1(1,+)\ \mbt2_\infty\ \mbt;_0\ \mbt3_\infty\ \mbt*_2\ \mbt4_\infty\ \mbt;_0\ \mbt]_0\cr
        &\LBRACK_0\ \OP\NUM_1(1,+)\ \NUM_\infty(2)\ \mbt;_0\ \mbt3_\infty\ \mbt*_2\ \mbt4_\infty\ \mbt;_0\ \mbt]_0\cr
        &\LBRACK_0\ \OP\NUM_1(1,+)\ \NUM_\infty(2)\ \COLON_0\ \mbt3_\infty\ \mbt*_2\ \mbt4_\infty\ \mbt;_0\ \mbt]_0\cr
        &\LBRACK_0\ \OP\NUM_1(1,+)\ \NUM_0(2)\ \mbt3_\infty\ \mbt*_2\ \mbt4_\infty\ \mbt;_0\ \mbt]_0\cr
        &\LBRACK_0\ \NUM_0(3)\ \mbt3_\infty\ \mbt*_2\ \mbt4_\infty\ \mbt;_0\ \mbt]_0\cr
        &\LBRACK\NUM_0((3))\ \mbt3_\infty\ \mbt*_2\ \mbt4_\infty\ \mbt;_0\ \mbt]_0\cr
        &\LBRACK\NUM_0((3))\ \NUM_\infty(3)\ \mbt*_2\ \mbt4_\infty\ \mbt;_0\ \mbt]_0\cr
        &\LBRACK\NUM_0((3))\ \NUM_\infty(3)\ \OP_2(*)\ \mbt4_\infty\ \mbt;_0\ \mbt]_0\cr
        &\LBRACK\NUM_0((3))\ \OP\NUM_2(3,*)\ \mbt4_\infty\ \mbt;_0\ \mbt]_0\cr
        &\LBRACK\NUM_0((3))\ \OP\NUM_2(3,*)\ \NUM_\infty(4)\ \mbt;_0\ \mbt]_0\cr
        &\LBRACK\NUM_0((3))\ \OP\NUM_2(3,*)\ \NUM_\infty(4)\ \COLON_0\ \mbt]_0\cr
        &\LBRACK\NUM_0((3))\ \OP\NUM_2(3,*)\ \NUM_0(4)\ \mbt]_0\cr
        &\LBRACK\NUM_0((3))\ \NUM_0(12)\ \mbt]_0\cr
        &\LBRACK\NUM_0((3,12))\ \mbt]_0\cr
        &\LBRACK\NUM_0((3,12))\ \RBRACK_0\cr
        &\LIST\NUM_0((3,12))\cr
    }

\end{example}


\section{Implementing the Algorithm}

We implement our algorithm in an interpreter for a toy language we dub ``ILang''.
We also create an interpreter for ILang using menhir\cite{menhir}.
In this section we detail the implementation of our algorithm and compare and contrast the two implementations.

\subsection{The Grammar}

The grammar for our toy language is pretty straight-forward:

\medskip
\grammar
\noalign{\hbox{\bf Identifiers}}
    letter&\ccoloneqq\(a\dots z\gbar A\dots Z\gbar\_\)\cr
    digit&\ccoloneqq\(0\dots9\)\cr
    non\_digit&\ccoloneqq\(\_\gbar{\it letter}\)\cr
    ident&\ccoloneqq{\it letter}\ \({\it digit}\gbar{\it non\_digit}\)^*\cr
    pident&\ccoloneqq {\bf\_prim\_} \({\it digit}\gbar{\it non\_digit}\)^*\cr
\noalign{\hbox{\bf Constant Expressions}}
    const&\ccoloneqq\({\it number}\gbar{\it product}\)\cr
    number&\ccoloneqq\({\it digit}\)^*[.\({\it digit}\)^*]\cr
\noalign{\hbox{\bf Operators}}
    op&\ccoloneqq\(@\gbar+\gbar-\gbar*\gbar/\gbar{<=}\gbar{<}\gbar{>=}\gbar{>}\gbar{==}\gbar{!}{=}\)\cr
\noalign{\hbox{\bf Expressions}}
    expr&\ccoloneqq\epsilon\cr
        &\bbar{\bf let}\ {\it ident}\ =\ {\it value}\ ;\ {\it expr}\cr
        &\bbar{\bf fun}\ {\it ident}\ (\ {\it plist}\ )\ \{\ {\it expr}\ \}\ {\it expr}\cr
        &\bbar{\bf if}\ (\ {\it value}\ )\ \{\ {\it expr}\ \}\ \{\ {\it expr}\ \}\ {\it expr}\cr
        &\bbar{\it funcall}\ ;\ {\it expr}\cr
        &\bbar{\it pident}\ {\it value}\ {\it expr}\cr
        &\bbar{\it value}\cr
\noalign{\hbox{\bf Values}}
    value&\ccoloneqq{\it const}\cr
        &\bbar{\it ident}\cr
        &\bbar{\it value}\ {\it op}\ {\it value}\cr
        &\bbar{\it funcall}\cr
        &\bbar(\ {\it product}\ )\cr
    product&\ccoloneqq{\it value}\cr
        &\bbar{\it value}\ ,\ {\it product}\cr
\noalign{\hbox{\bf Function Calls}}
    plist&\ccoloneqq{\it ident}\cr
        &\bbar{\it ident}\ ,\ {\it plist}\cr
    funcall&\ccoloneqq{\it value}\ {\it value}\cr
\egrammar

This basic grammar will suffice for our classical implementation.
For our algorithm, we will add more features (such as lists and nested products).

\subsection{The Initial $\beta$-Reducer}

Our algorithm is based on an initial $\beta$-reducer instead of a grammar.
Thus in order to implement our algorithm we must first form an initial $\beta$-reducer.
So we must translate our previous section to an initial $\beta$-reducer.

Instead of explicitly writing the sets $\mathcal A$ and $\Sigma$, base types will be underlined, atomic abstract terms will be written normally, and internal terms will be boxed.
General terms will be denoted by $\sigma,\tau$, and lists of terms will be denoted by $\Omega$.

\noindent{\bf End}:
\blist
    \item $\isig\ \eend \longto \isig\ \minfty\ (u,\_,s\to u,\epsilon,s)$
\elist

\noindent{\bf Arithmetic}:
\blist
    \item $\tsig\ \op \longto \op\tsig\ \snd\ (u,f,s\to(u,f),\epsilon,s)$
    \item $\op\tsig\ \op\tsig \longto \op\tsig\ \snd\ \bigl((u,f),(v,g),s\to (f(u,v),g),\epsilon,s\bigr)$
    \item $\op\tsig\ \tsig \longto \tsig\ \snd\ \bigl((u,f),v,s\to f(u,v),\epsilon,s\bigr)$
    \item $\Pop\ \tsig \longto \tsig\ \snd\ \bigl((f,g),u,s\to f(u),\epsilon,s\bigr)$
    \item $\tsig\ \Pop \longto \op\tsig\ {\sf one}\ \bigl(u,(f,g),s\to(u,g),\epsilon,s\bigr)$
    \item $\tsig\ \rparen \longto \rparen\tsig\ \snd\ (u,\_,s\to u,\epsilon,s)$
    \item $\op\tsig\ \rparen\tsig \longto \rparen\tsig\ \snd\ \bigl((f,u),v,s\to f(u,v),\epsilon,s\bigr)$
    \item $\Pop\ \rparen\tsig \longto \rparen\tsig\ \snd\ \bigl((f,g),u,s\to f(u),\epsilon,s\bigr)$
    \item $\lparen\ \rparen\tsig \longto \tsig\ \fst\ (\_,u,s\to u,\epsilon,s)$
\elist

\noindent{\bf Lists}:
\blist
    \item $\Lbrack\ \tsig \longto \Lbrack\tsig\ \fst\ (\_,u,s\to (u),\epsilon,s)$
    \item $\Lbrack\tsig\ \tsig \longto \Lbrack\tsig\ \fst\ (\ell,u,s\to (\ell,u),\epsilon,s)$
    \item $\Lbrack\tsig\ \Rbrack \longto \List\tsig\ \pinfty\ (\ell,\_,s\to\ell,\epsilon,s)$
    \item $\period\ \num \longto \index\ \zero\ (\_,n,s\to n,\epsilon,s)$
    \item $\List\tsig\ \index \longto \tsig\ \fst\ (\ell,i,s\to \ell_i,\epsilon,s)$
\elist

\noindent{\bf Variables}:
\blist
    \item $\lett\ x \longto \letvar\ \snd\ (\_,\_,s\to(x,\varnothing),\epsilon,s)$
    \item $\letvar\ \index \longto \letvar\ \fst\ \bigl((x,\ell),n,s\to(x,(\ell,n)),\epsilon,s\bigr)$
    \item $\letvar\ \equal \longto \leteq\ \minfty\ \bigl((x,\ell),\_,s\to(x,\ell),\epsilon,s\bigr)$
    \item $\leteq\ \isig \longto \epsilon\ \varnothing\ \bigl((x,\ell),v,s\to\epsilon,\epsilon,s'\bigr)$ where $s'$ is $s[x\mapsto\sigma(v)]$ if $\ell=\varnothing$ and otherwise let $t$ be the result of
        setting $s(x).\ell_1.\dots.\ell_n$ to $v$, then $s'=s[x\mapsto t]$.
\elist

\noindent{\bf Scoping}:
\blist
    \item $\Lbrace\ \epsilon \longto \epsilon\ \varnothing\ (\_,\_,s\to\epsilon,\epsilon,s+\varnothing)$
    \item $\Rbrace\ \epsilon \longto \epsilon\ \varnothing\ (\_,\_,s\to\epsilon,\epsilon,\pop s)$
\elist

\noindent{\bf Products}:
\blist
    \item $\tsig\ \comma \longto \comma(\tsig)\ \snd\ (u,\_,s\to(u),\epsilon,s)$
    \item $\op\tsig\ \comma(\tsig) \longto \comma(\tsig)\ \snd\ ((f,u),(v)\to (f(u,v)),\epsilon,s)$
    \item $\Pop\ \comma(\tsig) \longto \comma(\tsig)\ \snd\ ((f,g),(u)\to (f(u),\epsilon,s))$
    \item $\comma\tOmeg\ \comma(\tsig) \longto \comma(\tOmeg,\tsig)\ \snd\ (\ell,\ell',s\to(\ell,\ell'),\epsilon,s)$
    \item $\comma\tOmeg\ \rparen\tsig \longto \Listrparen(\tOmeg,\tsig)\ \snd\ (\ell,v\to (\ell,v),\epsilon,s)$
    \item $\lparen\ \Listrparen\tOmeg \longto \product\tOmeg\ \pinfty\ (\_,\ell,s\to \ell,\epsilon,s)$
\elist

\noindent{\bf Primitives}:
\blist
    \item $\primitive\ \isig \longto \epsilon\ \varnothing\ (f,v,s\to \epsilon,w,s)$ where $f(\isig,v)=(w,s')$ (the purpose is for $f$ to have a side effect)
\elist

\noindent{\bf Code Capture}
\blist
    \item $\Lbrace\a\ x\longto \Lbrace\a\ \pinfty\ (\xi,\_,s\to\xi x,\epsilon,s)$ if $x\neq\{,\}$
    \item $\Lbrace\a\ x\longto \code\ \pinfty\ (\xi,\_,s\to\xi,\epsilon,s)$
    \item $\Lbrace\a\ \code\longto \Lbrace\a\ \pinfty\ (\xi,\xi',s\to\xi\{\xi'\},\epsilon,s)$
\elist

\noindent{\bf Parameter Capture}
\blist
    \item $\lparen\a\ x \longto \lparen\a\ \fst\ (\ell,\_,s\to \ell @(x),\epsilon,s)$ for $x\neq(,)$
    \item $\lparen\a\ ) \longto \plist\ \fst\ (\ell,\_,s\to \ell,\epsilon,s)$
    \item $\lparen\a\ \plist \longto \lparen\a\ \fst\ (\ell,\ell',s\to (\ell @(\ell')),\epsilon,s)$
\elist

\noindent{\bf Function Definitions}
\blist
    \item $\fun\ x\longto \funname\ \pinfty\ (\_,\_,s\to(x,\epsilon), \epsilon, s + [\{\mapsto\Lbrace\a,\}\mapsto\Rbrace\a,(\mapsto\lparen\a,)\mapsto\rparen\a])$
    \item $\funname\ \plist \longto \funvars\ \pinfty\ \bigl((x,\epsilon),u,s \to (x,u),\epsilon,s\bigr)$
    \item $\funvars\ \code \longto$\hfil\break\null\hfill$\closure\ \fst\ \bigl((x,\ell),\xi,s\to C=\gen{\ell,\xi,s'[x\mapsto\closure(C)]},\epsilon,\pop s[x\mapsto\closure(C)]\bigr)$ where $s'=(\pop s)_c$.
\elist

\noindent{\bf Function Calls}
\blist
    \item $\closure\ \tsig \longto \epsilon\ \varnothing\ \bigl(\gen{\ell,\xi,{\it ps}},u,s\mapsto\epsilon,\xi\},s+_c{\it ps}[\ell\mapsto\tsig(u)]\bigr)$ where $\ell\mapsto\tsig(u)$ means that if
        $\ell=(x)$ then $x\mapsto \tsig(u)$.
        Otherwise $\ell=(x_1,\dots,x_n)$, $\tsig=\product\tsig_1\cdots\tsig_n$, and $u=(u_1,\dots,u_n)$ and $x_i\mapsto\tsig_i(u_i)$ (recursively).
\elist

\noindent{\bf If Statements}
\blist
    \item $\iif\ \tsig \longto \ifbooll\ \fst\ (\_,n,s\to n,\epsilon,s+[\{\mapsto\Lbrace\a,(\mapsto\lparen\a)]$
    \item $\ifbooll\ \code \longto \ifthen\ \fst\ (n,\xi,s\to(n,\xi),\epsilon,s)$
    \item $\ifthen\ \code \longto \epsilon\ \_\ ((n,\xi_1),\xi_2,s\to\varnothing,(n=0?\ \xi_2:\xi_1),\pop s)$
\elist

\noindent{\bf Types}
\blist
    \item $\tp\tsig\ \tp\ttau \longto \tp\tsig(\ttau)\ \snd\ (\_,\_,s\to \tsig(\ttau),\epsilon,s)$
    \item $\tp\tsig\ \product(\tp\ttau_1,\dots,\tp\ttau_n) \longto$\hfil\break\null\hfill$\tp\tsig(\ttau_1,\dots,\ttau_n)\ \snd\ (\_,\_,s\to \tsig(\ttau_1,\dots,\ttau_n),\epsilon,s)$
    \item $\ccolon\ \tp\tsig \longto \typer\tsig\ \snd\ (\_,u,s\to u,\epsilon,s)$
    \item $\tsig\ \typer\ttau \longto \ttau\ \snd\ (u,\_,s\to u,\epsilon,s)$
\elist

\subsection{The Initial State}

The initial state is a partial state, defined as follows:

\bigskip

\hbox{\vtop{\hsize=.48\hsize
\noindent{\bf End}
\blist
    \item $;{}\mapsto(\eend,\varnothing)$
\elist

\noindent{\bf Arithmetic}
\blist
    \item $({}\mapsto(\lparen,\varnothing)$
    \item $){}\mapsto(\rparen,\varnothing)$
    \item $+{}\mapsto(\op, (n,m\to n+m))$
    \item $+{}\mapsto(\op, (n,m\to n+m))$
    \item $*{}\mapsto(\op, (n,m\to n*m))$
\elist
}\hfil
\vtop{\hsize=.48\hsize
\blist
    \item $/{}\mapsto(\op, (n,m\to n/m))$
    \item $-{}\mapsto$\hfil\break\null\hfill$(\Pop, (n\to-n), (n,m\to n-m))$
    \item $@{}\mapsto(\op, (\ell_1,\ell_2\to\ell_1@\ell_2))$
    \item $!={}\mapsto(\op,(u,v\to u\neq v))$
    \item $<={}\mapsto(\op,(n,m\to n\leq m))$
    \item $>={}\mapsto(\op,(n,m\to n\geq m))$
    \item $=={}\mapsto(\op,(u,v\to u=v))$
\elist}}
\vfill\break

{\vtop{\vsize=.48\hsize
}}

\hbox{\vtop{\hsize=.48\hsize
\blist
    \item $<{}\mapsto(\op,(n,m\to n<m))$
    \item $>{}\mapsto(\op,(n,m\to n>m))$
\elist

\noindent{\bf Lists}
\blist
    \item $[{}\mapsto(\Lbrack,[])$
    \item $]{}\mapsto(\Rbrack,\varnothing)$
    \item $.\mapsto(\period,\varnothing)$
\elist

\noindent{\bf Variables}
\blist
    \item ${\rm let}\mapsto(\lett,\varnothing)$
    \item $={}\mapsto(\equal,\varnothing)$
\elist

\noindent{\bf Scoping}
\blist
    \item $\{{}\mapsto(\Lbrace,\varnothing)$
    \item $\}{}\mapsto(\Rbrace,\varnothing)$
\elist

\noindent{\bf Products}
\blist
    \item $,{}\mapsto(\comma,\varnothing)$
\elist}\hfil

\vtop{\hsize=.48\hsize
\noindent{\bf Primitives}
\blist
    \item ${\rm\_prim\_print}\mapsto$\hfil\break
        \null\kern-1.6pt$(\primitive,(a,v\to{\rm print}(v); (\varnothing,\varnothing)))$
    \item ${\rm\_prim\_len}\mapsto$\hfil\break\null\hfill$(\primitive,(a,\ell\to\num,\abs\ell))$
    \item ${\rm\_prim\_tail}\mapsto$\hfil\break\null\hfill$(\primitive,(\tsig,t::\ell\to\tsig,\ell))$
    \item ${\rm\_prim\_type}\mapsto$\hfil\break\null\hfill$(\primitive,(\tsig,\_\to\tp\tsig,\tsig))$
\elist

\noindent{\bf Keywords}
\blist
    \item ${\rm fun}\mapsto(\fun,\varnothing)$
    \item ${\rm if}\mapsto(\iif,\varnothing)$
\elist

\noindent{\bf Types}
\blist
    \item $:{}\mapsto(\colon,\varnothing)$
    \item ${\rm Num}\mapsto(\tp\ \num,\num)$
    \item ${\rm List}\mapsto(\tp\ \List,\List)$
    \item ${\rm Closure}\mapsto(\tp\ \closure,\closure)$
    \item ${\rm Product}\mapsto(\tp\ \product,\product)$
    \item ${\rm Primitive}\mapsto$\hfil\break\null\hfill$(\tp\ \primitive,\primitive)$
    \item ${\rm Type}\mapsto(\tp\ \tp, \tp)$
\elist
}}

\section{Proving Correctness}

\def\eval{\hbox{\tencsc eval}}
\def\unparen{\hbox{\tencsc unparen}}

In this section we show that valued reduction (\S\ref{valued-reduction}) computes arithmetical expressions correctly.
To do so, we show that valued reduction computes expressions and gives a result equal to a na\"\i ve algorithm.

But first, we must define the problem.
We are given the following:
\begin{enumerate}
    \item a set $\s X$ which is our \textit{universe} (e.g. numbers),
    \item a set $\s S$ of \textit{operator symbols},
    \item for every $\s s\in\s S$ a \textit{priority} $\pi(\s s)\in\bbN$,
    \item for every $\s s\in\s S$ a function $f_{\s s}\colon\s X\times\s X\longto\s X$.
\end{enumerate}
We also take two symbols $\s L$ and $\s R$ for the left and right parentheses.
$\s X,\s S,\s L,\s R$ will also be our symbols for the $\beta$-reduction.

Expressions are defined by the following grammar:
\[ {\it expr} \ccoloneqq \s L\ {\it expr}\ \s R  \gbar {\it expr}\ \s S\ {\it expr} \gbar \s X \]
Operators are assumed to be left-associative.

Let us define $\unparen(\xi,i)$ to mean that the $i$th character in $\xi$ is not within parentheses (this can be implemented easily).
We define the \eval{} algorithm (see algorithm \ref{alg:eval}) to evaluate strings in ${\it expr}$.

\begin{algo}
\algorithm
\Function{eval}{$\xi$}
    \If{$\xi=\s x\in\s X$}
        \State\Return $\s x$
    \ElseIf{$\xi[0]=\s L$}
        \State $\xi$ is of the form $\s L\xi'\s R\zeta$
        \State\Return $\eval(\eval(\xi')\zeta)$
    \Else
        \Comment Find the greatest index with the smallest operator.\cr
        Note that $\max_i{\rm argmin}_if(i)$ is the maximal $i$ which minimizes $f$.\EndComment
        \State $i\coloneqq\max_i{\rm argmin}_i\set{\pi(\xi[i])}[{\xi[i]\in\s S,\unparen(\xi,i)}]$
        \State $\s s\coloneqq\xi[i]$
        \Comment $\xi'=\xi[:i-1]$, $\xi''=\xi[i+1:]$ \EndComment
        \State $\xi$ is of the form $\xi'\s s\xi''$
        \State\Return $f_{\s s}(\eval(\xi'),\eval(\xi''))$
    \EndIf
\EndFunc
\ealgorithm
\caption{\eval uating arithmetical expressions}
\label{alg:eval}
\end{algo}

As opposed to pure valued (stateless) reduction, we adopt some conventions from stateful reduction.
Since our string is a string in $(\set{\s L,\s R}\cup\s X\cup\s S)^*$ and not $\set{\s L,\s R,\s X,\s S}^*$ (note the difference!), we must first convert the string into one admissable for
$\beta$-reduction.
To do so, we use stateful reduction and use the initial state and priority map which maps elements $\s x\in\s X$ to $\s X_\infty(\s x)$, $\s S\in\s S$ to $\s S_{\pi(\s s)}(f_{\s s})$, $\s L$ to
$\s L_\infty$, and $\s R$ to $\s R_0$.
Since our state doesn't change (our initial $\beta$-reducer will not affect the state) we can assume that our string has been mapped to its associated $\oe$-string from the start.
That is, instead of strings like \ttt{1+2}, we can assume that our input strings are of the form $\s X_\infty(1)\ \s S_1(+)\ \s X_\infty(2)$.

Secondly, we adopt the convention of having type terms, abstract terms, etc.
Our base type will be $\Sigma=\set{\s X}$, and our atomic abstract terms $\mathcal A=\set{\s L_0,\s R_1,\s S_1}$ (printable terms are $\set{\s L,\s R}\cup\s X\cup\s S$, but as said before we assumed these
are already altered by the state).

Our initial $\beta$-reducer will be
\begin{itemize}
    \item $\s X\ \s S\longto\s S\s X\ \snd\ (u,f\to(u,f))$
    \item $\s S\s X\ \s S\s X \longto\s S\s X\ \snd\ ((u,f),(v,g)\to(f(u,v),g))$
    \item $\s S\s X\ \s X\longto\s X\ \snd\ ((u,f),v\to f(u,v))$
    \item $\s X\ \s R \longto \s R\s X\ \snd\ (u,\_\to u)$
    \item $\s S\s X\ \s R\s X \longto\s R\s X\ \snd\ ((u,f),v\to f(u,v))$
    \item $\s L\ \s R\s X \longto\s X\ \fst\ (\_,u\to u)$
\end{itemize}

\subsection{The Proof}

We can rewrite the grammar ${\it expr}$ with priorities as follows:
\[ {\it expr} \ccoloneqq \s X_\infty \gbar \s X_\infty\ \s S_n\ {\it expr} \gbar \s L_\infty\ {\it expr}\ \s R_0 \gbar \s L_\infty\ {\it expr}\ \s R_0\ \s S_n\ {\it expr} \]
when considering an input for $\eval$, we will of course neglect the priorities in the string.
And when considering an input for $\beta$-reduction, we act as if each character is of the term indicated with the value in the string (i.e. $1_\infty+_12_\infty\in{\it expr}$ is
$\s X_\infty(1)\s S_1(+)\s X_\infty(2)$).

Let us define the set of {\it intermediate expressions} as
\begin{multline*}
    {\it intexpr} \ccoloneqq \s X_n\gbar \s S\s X_n\ {\it intexpr} \gbar \s X_n\ \s S_m\ {\it intexpr}\gbar \s L_\infty\ {\it intexpr}\ \s R_0\ {\it opintexpr}\\
    \gbar \s L_\infty\ (\s S\s X_n)^*\ \s R\s X_0\ {\it opintexpr}
\end{multline*}
\[ {\it opintexpr} \ccoloneqq \epsilon \gbar \s S_n\ {\it intexpr} \]
where $m\leq n\in\bbN$.

Let $\beta_0$ be the normal derived $\beta$-reducer.
And let $\beta$ be the derived $\beta$-reducer without the rule that a single character's priority is changed to zero (instead it just keeps the character's priority instead).
We define $\beta^*(\xi)$ to be the value of the full reduction of $\xi$ under $\beta$ (i.e. the string obtained by repeated applications of $\beta$ until convergence).
And $\beta^*_0(\xi)$ is defined similarly.

\begin{definition}

    A set of strings $S$ is \emph{closed under $\beta$-reductions} if when $\xi\in S$, then $\beta(\xi)\in S$
    And $S$ is \emph{closed under $\beta_0$-reductions} if when $\xi\in S$, then $\beta_0(\xi)\in S$.

\end{definition}

Obviously if $S$ is closed under $\beta_0$-reductions, it is closed under $\beta$-reductions.

\begin{lemma}

    ${\it intexpr}$ is closed under $\beta_0$-reductions, and for $\xi\in{\it intexpr}$, $\beta^*(\xi)=\s S\s X_{n_1}\cdots\s S\s X_{n_k}\s X_{n_{k+1}}$ where $k\geq0$ and $n_1<\cdots<n_{k+1}$.

\end{lemma}

\begin{proof}

    We prove this by induction on the length and structure of $\xi$.
    \begin{enumerate}
        \item For $\xi=\s X_n$, this is trivial as $\xi$ is a fixed-point of $\beta$.
        \item For $\xi=\s S\s X_n\xi'$, if $\s S\s X_n$ can be reduced with the first token in $\xi'$ then we have the following cases:
        \begin{enumerate}
            \item $\xi'=\s X_m$, then $\beta(\xi)=\s X_m$ which is an intermediate expression and of the desired form.
            \item $\xi'=\s S\s X_m\xi''$, then $\beta(\xi)=\s S\s X_m\xi''$ which is an intermediate expression, and since the length of this string is less than $\xi$, we can prove the second part of
            the lemma by induction.
            \item $\xi'=\s X_m\ \s S_k\xi''$ with $\xi''\in{\it intexpr}$, in which case $\beta(\xi)=\s X_m\s S_k\xi''$, which is in ${\it intexpr}$ (since $m\geq k$).
            And since the length of this string is one less than $\xi$, we prove the second part of the lemma by induction.
        \end{enumerate}
        Otherwise $\beta(\xi)=\s S\s X_n\beta(\xi')$, and since by induction $\beta(\xi')\in{\it intexpr}$ we have the first part of the lemma.
        For the second part, if $\xi'$ is not a fixed point of $\beta$, $\beta(\xi')$'s length is less than $\xi'$'s, and thus since $\beta^*(\xi)=\beta^*(\s S\s X_n\beta(\xi'))$ we can proceed by
        induction.
        If $\xi'$ is a fixed point of $\beta$, by our inductive assumption (the second part of the lemma), $\xi'=\s S\s X_{n_1}\cdots\s S\s X_{n_k}\s X_{n_{k+1}}$.
        And so $\xi$ is also a fixed point of $\beta$ and has the desired form (since $n<n_1$ as otherwise we could reduce $\xi$).
        \item For $\xi=\s X_n\s S_m\xi'$, this can be reduced to $\beta(\xi)=\s S\s X_m\xi'$ and we simply induct.
        \item For $\xi=\s L_\infty\xi'\s R_0\zeta$, note that since $\xi'$ doesn't start with $\s R\s X$, $\s L$ cannot be reduced with $\xi'$.
        Thus $\beta(\xi)=\s L_\infty\beta(\xi'\s R_0\zeta)$.
        If $\xi'$ can be reduced, this is just $\s L_\infty\beta(\xi')\s R_0\zeta$ and so we simply induct.

        Otherwise it is a fixed point and so $\xi'=\s S\s X_{n_1}\cdots\s S\s X_{n_k}\s X_{n_{k+1}}$ with $n_1<\cdots<n_{k+1}$.
        Then $\beta(\xi)=\s L_\infty\s S\s X_{n_1}\cdots\s S\s X_{n_k}\s R\s X_0\zeta$ which is an intermediate expression whose length is shorter than $\xi$ so we induct.
        \item For $\xi=\s L_\infty\s S\s X_{n_1}\cdots\s S\s X_{n_k}\s R\s X_0\zeta=\s L_\infty\xi'\s R\s X_0\zeta$, if $\xi'$ can be reduced or is empty
        (because $\s L_\infty\s R\s X_0\zeta\to\s X_\infty\zeta$), we simply induct.
        Otherwise $n_1<\cdots<n_k$ and so $\beta(\xi)=\s L_\infty\s S\s X_{n_1}\cdots\s S\s X_{n_{k-1}}\s R\s X_0\zeta$, which is an intermediate expression whose length is shorter.
        \qed
    \end{enumerate}

\end{proof}

Notice that $\beta^*_0(\s S\s X_{n_1}\cdots\s S\s X_{n_k}\s X_{n_{k+1}})\in\s X$ (this can be proved by simple induction), and so by the above lemma we get that for any intermediate expression $\xi$,
$\beta^*_0(\xi)\in\s X$ (since $\beta^*_0(\xi)=\beta^*_0(\beta^*(\xi))$).

Furthermore, from $({\bf4})$ we see that $\beta^*(\s L_\infty\xi\s R_0)=\s L_\infty\beta^*(\xi)\s R_0$.
Since $\beta^*(\xi)=\s S\s X_{n_1}\cdots\s S\s X_{n_k}\s X_{n_{k+1}}$, it is trivial to then see that $\beta^*(\s L_\infty\xi\s R_0)=\beta^*_0(\xi)_\infty$ (we can assign $\beta^*_0(\xi)$ a priority
since as we said, it is in $\s X$).
So we have proven:

\begin{lemma}

    Let $\xi\in{\it intexpr}$, then $\beta^*(\s L_\infty\xi\s R_0)=\beta^*_0(\xi)_\infty$.

\end{lemma}

We introduce some more notation.
Let us write $\xi\to^*\xi'$ to mean that $\beta^n(\xi)=\xi'$ for some $n$ and $\xi\to^*_0\xi'$ to mean that $\beta^n_0(\xi)=\xi'$ for some $n$.
We write $\s s_n$ for $\s S_n(f_{\s s})$, $\s s_n[\s x]$ for $\s S\s X_n(\s x,f_{\s s})$, and $\s x_n$ for $\s X_n(\s x)$.
And if $\xi\in{\it intexpr}$ we write $\pi(\xi)$ for the set of priorities in $\xi$, and $\pi_u(\xi)$ for the set of priorities in $\xi$ of operators which are unparenthesized.

\begin{lemma}

    If $N\leq\pi_u(\xi)$ then $N\leq\pi_u(\beta(\xi))$ for $\xi\in{\it intexpr}$.
    If the first inequality is strict, so is the second.

\end{lemma}

\begin{proof}

    We prove this by induction on the length of $\xi$.
    \begin{enumerate}
        \item For $\xi=\s X_n$ this is trivial.
        \item For $\xi=\s S\s X_n\xi'$, if $\s S\s X_n$ can be reduced with the first token of $\xi'$, we simply note that it takes the second token's priority, which $N$ is already less than.
        Otherwise $\beta(\xi)=\s S\s X_n\beta(\xi')$ and so $\pi_u(\beta(\xi))=\set n\cup\pi_u(\beta(\xi'))\geq N$ as required.
        \item For $\xi=\s X_n\s S_m\xi'$, $\beta(\xi)=\s S\s X_m\xi'$ and this is trivial.
        \item For $\xi=\s L_\infty\xi'\s R_0\zeta$, a $\beta$-reduction gives a string of the form $\s L_\infty\xi''\s R\s X_0\zeta$ and so $\pi_u(\beta(\xi))=\pi_u(\zeta)\geq N$.
        \item For $\xi=\s L_\infty\xi'\s R\s X_0\zeta$, a $\beta$-reduction either gives a string of the form $\s L_\infty\xi''\s R\s X_0\zeta$ as before, or $\s X_\infty\zeta$.
        The first case was covered in the last point, the second case is simple: $N\leq\pi_u(\zeta)$ and certainly $N\leq\infty$.
    \end{enumerate}
    Note that if we have a strict inequality, all of our arguments still hold.
    \qed

\end{proof}

From this and the previous lemma we can infer that if $n\leq\pi_u(\xi)$ then $n\leq\pi_u(\beta^*(\xi))=\pi(\beta^*(\xi))$ (since $\beta^*(\xi)$ cannot have parentheses).
So $\beta^*(\xi)$ is of the form
\[ \s S\s X_{n_1}\cdots\s S\s X_{n_k}\s X_{n_{k+1}},\qquad n\leq n_1<\cdots<n_{k+1} \]

\begin{lemma}

    Let $\xi$ be an intermediate expression, and $n\leq\pi_u(\xi)$.
    Then $\beta^*(\xi\s s_n)=\s s_n[\beta^*_0(\xi)]$.

\end{lemma}

\begin{proof}

    As explained above,
    \[ \xi\s s_n \to^* \beta^*(\xi)\s s_n = \s s^1_{n_1}[\s x^1]\cdots\s s^k_{n_k}[\s x^k]\s x^{k+1}_{n_{k+1}}\s s_n \]
    for $n\leq n_1<\cdots<n_k<n_{k+1}$.
    A $\beta$-reduction gives
    \[ \s s^1_{n_1}[\s x^1]\cdots\s s^k_{n_k}[\s x^k]\s s_n[\s x^{k+1}] \]
    further $\beta$-reductions give (instead of $f_{\s s_i}$ we write $f_i$)
    \[ \s s^1_{n_1}[\s x^1]\cdots\s s^{k-1}_{n_{k-1}}[\s x^{k-1}]\s s_n[f_k(\s x^k,\s x^{k+1})] \to \cdots \to \s s_n\bigl[f_1(\s x^1,f_2(\s x^2,\dots))\bigr] \]
    And it isn't hard to show that the $\beta^*_0$-reduction of $\s s^1_{n_1}[\s x^1]\cdots\s s^k_{n_k}[\s x^k]\s x^{k+1}_{n_{k+1}}$ is precisely $f_1(\s x^1,f_2(\s x^2,\dots))$ as required.
    \qed

\end{proof}

\begin{lemma}

    If $\xi\in{\it intexpr}$, $n<\pi_u(\xi)$.
    Then $\beta^*_0(\s s_n[\s x]\xi)=f_{\s s}(\s x,\beta^*_0(\xi))$.

\end{lemma}

\begin{proof}

    Since $n<\pi(\xi)$, $\s s_n[\s x]$ cannot be reduced with $\xi$, and since $n<\pi_u(\beta^k(\xi))$ for all $k$.
    Since $\s s_n[\s x]$ can only reduce with unparenthesized expressions (that is, there is no rule reducing $\s S\s X$ and $\s L$), this means that $\s s_n[\s x]$ cannot be reduced until $\xi$ is
    reduced fully.
    So
    \[ \s s_n[\s x]\xi \to^* \s s_n[\s x]\beta^*(\xi) = \s s_n[\s x]\s s_{n_1}[\s x^1]\cdots\s s_{n_k}[\s x^k]\s x^{k+1}_{n_{k+1}} \]
    where $n<n_1<\cdots<n_{k+1}$.
    A $\beta_0$-reduction just changes the priority of $\s x^{k+1}$ to $0$.
    Then $\beta^*_0$-reducing gives as before
    \[ f_{\s s}(\s x,f_{\s s_1}(\s x^1,f_{\s s_2}(\s x^2,\dots))) = f_{\s s}(\s x,\beta^*_0(\xi)) \qed \]

\end{proof}

\begin{theorem}

    For $\xi\in{\it expr}$, $\eval(\xi)=\beta^*_0(\xi)$.

\end{theorem}

\begin{proof}

    We induct on the length of $\xi$.
    \begin{enumerate}
        \item If $\xi=\s X_m$ this is trivial.
        \item If $\xi=\s L_\infty\xi'\s R_0\zeta$ then $\xi\to^*=\beta^*_0(\xi')\zeta$ which inductively is equal to $\eval(\xi')\zeta$.
        And inductively $\beta^*_0(\eval(\xi')\zeta)=\eval(\eval(\xi')\zeta)$ which is equal to $\eval(\xi)$ by definition.
        \item Otherwise let $n$ be the lowest priority of operators in $\xi$ which are unparenthesized, i.e. $n=\min\pi_u(\xi)$.
        Then $\xi=\xi'\s s_n\xi''$ where $\s s$ is the last unparenthesized operator with a priority of $n$, so $\xi',\xi''\in{\it intexpr}$ and $n\leq\pi_u(\xi')$ and $n<\pi_u(\xi'')$.
        This means that
        \[ \xi \to^* \s s_n[\beta^*_0(\xi')]\xi'' \to^*_0 f_{\s s}(\beta^*_0(\xi'),\beta^*_0(\xi'')) \]
        Inductively $\beta^*_0(\xi')=\eval(\xi')$ and $\beta^*_0(\xi'')=\eval(\xi'')$, meaning this is equal to $f_{\s s}(\eval(\xi'),\eval(\xi''))$.
        By definition this is $\eval(\xi)$ as required.
        \qed
    \end{enumerate}

\end{proof}

\section{Producing Parse Trees} \label{producing-parse-trees}

Iterative reduction can be used to just parse, instead of parsing and interpreting simultaneously.
This has its benefits, as separating parsing and interpretation allows for the inspection of code before running it, which can help alert the programmer to syntax errors.
Furthermore, this means iterative reduction can be used in the classical interpreter and compiler pipeline, as it can be used as a parser.

To do so, we define $\tree$, the set of trees, as follows:
\[ \tree \ccoloneqq \Sigma \gbar \Sigma(\tree) \gbar \Sigma(\tree)(\tree) \gbar \Sigma(\tree)(\tree)(\tree) \gbar \cdots \]
So a tree is simply a multi-branched tree whose nodes are elements of our alphabet $\Sigma$.
Then we define an \textit{initial $\beta$-reducer} as
\[ \hb\colon \Sigma\times\Sigma \partial \Sigma \times (\bbZ\times\bbZ\to\bbZ) \times (\tree\times\tree\to\tree) \]
This extends to a \textit{derived $\beta$-reducer}
\[ \beta\colon (\oS\times\tree)^* \longto (\oS\times\tree)^* \]
where $\beta(\xi)$ is defined as
\begin{enumerate}
    \item If $\xi=\sigma^1_n(t)\sigma^2_m(s)\xi'$ where $n\geq m$ and $\hb(\sigma^1,\sigma^2)=(\tau,\rho,f)$ is defined then $\beta(\xi)=\tau_{\rho(n,m)}(f(t,s))\xi'$.
    \item Otherwise $\beta(\xi)=\sigma^1_n(t)\beta(\sigma^2_m(s)\xi')$.
\end{enumerate}
We can also add the case that if $\xi$ is a single token then $\beta(\xi)=\xi_0$.

For example, for arithmetic we can define
\blist
    \item $\NUM\ \OP\to\OP\NUM,\snd,(t,f\mapsto f(t))$
    \item $\OP\NUM\ \NUM\to \NUM,\snd,(f(t),s\mapsto f(t)(s))$
    \item $\OP\NUM\ \OP\NUM\to \OP\NUM,\snd,\bigl(f(t),g(s)\mapsto g(f(t)(s))\bigr)$
    \item $\NUM\ \RPAREN\to \RPAREN\NUM,\snd,(t,\_\mapsto t)$
    \item $\OP\NUM\ \RPAREN\NUM\to \RPAREN\NUM,\snd,(f(t),s\mapsto f(t)(s))$
    \item $\LPAREN\ \RPAREN\NUM\to \NUM,\fst,(\_,t\mapsto t)$
\elist

So for example, \ttt{1 + 2 * (3 + 4)} is then parsed as
\begin{align*}
    \mb1_\infty \mb+_1 \mb2_\infty \mb*_2 \mb(_\infty \mb3_\infty \mb+_1 \mb4_\infty \mb)_0 &\to^* \mb{+(1)}_1 \mb{*(2)}_2 \mb(_\infty \mb{+(3)}_1 \mb{4}_0\\
    &\to \mb{+(1)}_1 \mb{*(2)}_2 \mb(_\infty \mb{+(3)(4)}_0\\
    &\to \mb{+(1)}_1 \mb{*(2)}_2 \mb{+(3)(4)}_\infty\\
    &\to^* \mb{+(1)}_1 \mb{*(2)(+(3)(4))}_0\\
    &\to \mb{+(1)(*(2)(+(3)(4)))}_0
\end{align*}
\gobble)\gobble)

\section{Optimizing the Algorithm}

Iterative reduction is an $\Theta(n^2)$-time algorithm under the assumption that every reduction reduces the number of tokens by one: (which is the case in the language provided), and no reduction yields a string of printable terms (e.g. when creating parse trees).
This is because a string of the form $\s s^1_1\s s^2_2\cdots\s s^n_n$ will take $n$ applications of the $\beta$-reducer, each application taking $n-k$ iterations (since $\beta$ is recursive).

But we can make this more efficient; indeed, iterative reduction can be made into a $\Theta(n)$-time algorithm.
Currently, the implementation of iterative reduction is as follows (assuming the existence of $\hb$):

\def\bhelp{\hbox{\tencsc$\hb$-helper}}
\begin{algo}[h]
\algorithm
    \Function{$\beta$-helper}{$\xi,\bar s$}
        \State $\xi = \sigma^1_n(u)\sigma^2_m(v)\xi'$
        \lIf{$\sigma^1\in\termp$} \Return $\gen{\bar s(\sigma^1)_n\sigma^2_m(v)\xi'}[\bar s']$
        \If{$\hb(\sigma^1,\epsilon)=(\tau,\rho,f)$ is defined}
            \State $(w,\zeta,\bar s')\gets f(u,\_,\bar s)$
            \State $\gen{\xi''}[\bar s'']\gets\beta^*\gen{\pi(\zeta)}[\bar s']$
            \State $n'\gets \rho(n,\_)$
            \State\Return $\gen{\tau_{n'}(w)\xi''\xi'}[\bar s'']$
        \ElseIf{$n\geq m$ and $\hb(\sigma^1,\sigma^2)=(\tau,\rho,f)$ is defined}
            \State $(w,\zeta,\bar s')\gets f(u,v,\bar s)$
            \State $\gen{\xi''}[\bar s'']\gets\beta^*\gen{\pi(\zeta)}[\bar s']$
            \State $n'\gets \rho(n,m)$
            \State\Return $\gen{\tau_{n'}(w)\xi''\xi'}[\bar s'']$
        \Else
            \State\Return undefined
        \EndIf
    \EndFunc
    \nonum\State
    \Function{$\beta$}{$\xi,\bar s$}
        \If{$\xi=\epsilon$} \Return $\gen\xi[\bar s]$
        \ElseIf{$\bhelp\gen\xi[\bar s]=\gen{\xi'}[\bar s']$ is defined}
            \Return $\gen{\xi'}[\bar s']$
        \Else
            \State $\xi=\sigma_n(u)\xi'$
            \State $\gen{\xi''}[\bar s']\gets\beta\gen{\xi'}[\bar s]$
            \State\Return $\gen{\sigma_n(u)\xi''}[\bar s']$
        \EndIf
    \EndFunc
    \nonum\State
    \Function{$\beta^*$}{$\xi,\bar s$}
        \State $\gen{\xi'}[\bar s']\gets\beta\gen\xi[\bar s]$
        \If{$\xi==\xi'$} \Return $\gen\xi[\bar s]$
        \Else\ \Return $\beta^*\gen{\xi'}[\bar s']$
        \EndIf
    \EndFunc
\ealgorithm
\end{algo}

All \bhelp{} does is check if $\hb$ can be applied to the current token(s), it cannot be optimized in a significant manner.
What we will optimize is the manner in which we apply $\beta$.
We can think of our algorithm as having a pointer to the current token in the stream.
If \bhelp{} can be applied at this pointer, then we alter the stream accordingly, and move the pointer to the beginning, and
repeat.

But notice that if we have a stream of tokens $\s s^1\cdots\s s^k\cdots\s s^n$ (the current token is $\s s^k$), and we can apply \bhelp{}, we get $\s s^1\cdots\s s^{k-1}\s t\cdots\s s^n$.
Now, the fact that the pointer was at $\s s^k$ means that it could not have reduced any of the tokens $\s s^1,\dots,\s s^{k-1}$.
So going back to the beginning will waste time: we don't need to check indices $1,\dots,k-2$.
Instead what we will do is move the pointer back one (as now it is possible that $\s s^{k-1}$ and $\s t$ can be reduced).

And if $\hb$ cannot be applied at the current pointer, we increment the pointer to the next token (since this is the final rule
in iterative reduction).

\begin{algo}
\algorithm
    \Function{$\hb^*$}{$\xi,\bar s$}
        \If{$\xi=\epsilon$} \Return $(\gen\xi[\bar s],\bot)$
        \ElseIf{$\bhelp\gen\xi[\bar s]=\gen{\xi'}[\bar s']$ is defined} \Return $(\gen{\xi'}[\bar s'],\top)$
        \Else
            \State $\xi=\sigma^1_n(u)\xi'$
            \State $(\gen{\xi''}[\bar s'],\s X)\gets\hb^*\gen{\xi'}[\bar s]$
            \lIf{$\s X$} \Return $\hb^*\gen{\sigma^1_n(u)\xi''}[\bar s']$
            \lElse \Return $(\gen{\sigma^1_n(u)}[\bar s'],\bot)$
        \EndIf
    \EndFunc
    \nonum\State
    \Function{$\beta^*$}{$\xi,\bar s$}
        \State $(\gen{\xi'}[\bar s'],\s X)\gets\hb^*\gen\xi[\bar s]$
        \lIf{$\s X$} \Return $\beta^*\gen{\xi'}[\bar s']$
        \lElse \Return $\gen{\xi'}[\bar s']$
    \EndFunc
\ealgorithm
\end{algo}

The algorithm was explained intuitively above, we now focus on how this implementation is faithful to the explanation.
Firstly, $\beta^*$ calls $\hb^*$, and $\hb^*$ checks if $\bhelp$ can be applied at the current pointer.
If it can, then it applies it and returns (essentially moving the pointer back one).
It also returns $\top$, meaning it successfully applied a reduction.

If it cannot apply $\bhelp$, then it moves forward one and applies $\hb^*$.
Now, if this returns $\bot$, this means that no reductions we performed.
This means that all we know is that the next reduction is before the current token, so we have to go back to the start.
Thus we continue returning $\bot$ to the end.
If it returned $\top$, then there was a reduction performed at the subsequent token, so we try to continue reducing at the current
token (since we know we cannot reduce previous tokens).

\begin{theorem} \label{thrm:complexity}

    Assuming $\hb$ is $O(1)$, no reductions produce a stream of printable tokens (as is the case with creating parse trees), and
    every application of $\hb$ reduces the number of tokens by one, then this algorithm is $O(n)$.

\end{theorem}

\begin{proof}

    Without loss of generality, we will assume that we always reduce a single token (i.e. we never perform
    $\hb(\sigma^1,\sigma^2)$, instead always performing $\hb(\sigma^1,\epsilon)$).
    And we will ignore states, since their change does not affect time complexity (since $\hb$ is $O(1)$).

    We will alter our algorithm slightly: for every token $\sigma$, define $\#\sigma=2$.
    Now, when we call $\hb^*(\sigma^1\cdots\sigma^n)$, we decrement $\#\sigma^1$ by $1$.
    If $\hb(\sigma^1,\epsilon)$ is defined, then we increment $\#\sigma^0$ by $1$ ($\sigma^0$ is the token
    before $\sigma^1$, or $\sigma^2$ if $\sigma^1$ was the first token).

    We claim that $\sigma$ can only be reduced if $\#\sigma=1$, and this means that $\#\xi=\sum_{\sigma\in\xi}\#\sigma$ is
    decremented by $1$ at each call to $\hb^*$ and never incremented.
    Thus if we can also show that $\#\sigma$ is always non-negative, then we have shown that we call $\hb^*$ at most $2n$ times,
    and so the algorithm takes $O(n)$ time.

    Notice that if we go passed $\sigma$, then it will only be revisited if the subsequent token is reduced.
    Suppose that the subsequent token is not reduced, then we only work backward if the algorithm reaches the end of the string,
    but then $\hb^*$ will return $\bot$, and it will not be called again.
    This means that if $\#\sigma=1$ and $\sigma$ is not reduced, then $\#\sigma$ can never become $0$ since it is revisited only if
    the next token is reduced, which would increment $\#\sigma$ by $1$.
    \qed

\end{proof}

\section{Comparing Implementations}

In this section we compare the runtimes of both implementations (one using iterative reduction and one using menhir\cite{menhir}).
A few notes beforehand:
\begin{itemize}
    \item The iterative reduction implementation has more features than the menhir implementation, this should not severely impact the comparisons and we will of course not be comparing the implementations
            on code which the menhir implementation does not support.
    \item ILang supports left composition.
            Meaning code of the form \ttt{f x y} is read as \ttt{(f x) y}.
            We found no way of supporting this with menhir.
            This is because our grammar for the menhir implementation contains the following fragment:
            \[ {\it value} \ccoloneqq {\it const}\gbar{\it ident}\gbar{\it funcall},\qquad {\it funcall}\ccoloneqq{\it value}\ {\it value} \]
            So \ttt{f x y} can be parsed as \ttt{f (x y)} instead:

            \centerline{\begin{tikzpicture}[
                    level 1/.style = {sibling distance=10em},
                    level 2/.style = {sibling distance=10em},
                    level 3/.style = {sibling distance=10em},
                    level 4/.style = {sibling distance=10em},
                    level 5/.style = {sibling distance=10em},
                    level 6/.style = {sibling distance=10em},
                    ]
                \node {\it value}
                    child {node {\it funcall}
                        child {node {\it value}
                            child {node {\it ident}
                                child {node {\ttt f}}
                            }
                        }
                        child {node {\it value}
                            child {node {\it funcall}
                                child {node {\it value}
                                    child {node {\it ident}
                                        child {node {\ttt x}}
                                    }
                                }
                            }
                            child {node {\it funcall}
                                child {node {\it value}
                                    child {node {\it ident}
                                        child {node {\ttt y}}
                                    }
                                }
                            }
                        }
                    };
            \end{tikzpicture}
            }
\end{itemize}

\subsection{Currying}

We begin with a simple program to demonstrate currying.
Currying is the action of taking a function $f\colon X\times Y\longto Z$ and converting it to a function $c(f)\colon X\longto(Y\longto Z)$ where $c(f)(x)\colon y\mapsto f(x,y)$.
Our ILang code is as follows:

\lstinputlisting[language=Caml, frame=single]{../Demos/currying.ml}

Comparing the time it takes both implementations to run this 300 times, we see that it takes iterative reduction (unoptimized) 0.001055 seconds, optimized iterative reduction 0.000998 seconds, and the classical implementation (menhir) 0.000866 seconds.

\begin{figure}

    \centerline{\includegraphics[width=\hsize]{../Docs/Images/comparer.png}}
    \caption{Time to compute \ttt{currying.ml}}
    \label{fig:curry}

\end{figure}

\subsection{Arithmetical Expressions}

We can generate random arithmetical expressions using the following algorithm:

\medskip
\algorithm
\Comment Create an expression with $\ell$ subterms, with a parentheses depth of $d$,\cr where numbers are chosen from $[0,n)$.\EndComment
\Function{Generate-Expression}{$\ell,d,n$}
    \lIf{$d=0$} \vtop{\hsize=.8\hsize
        \noindent \Return an expression with $\ell$ randomly chosen numbers in\hfil\break $[0,n)$ and $\ell-1$ random operators in $\set{+,-,\times,\div}$.}
    \State \Return $\bigl(\hbox{\tencsc Generate-Expression}(\ell,d-1,n)\bigr)\circ_1\cdots\circ_{\ell-1}$
    \nonum\State \hfill$\bigl(\hbox{\tencsc Generate-Expression}(\ell,d-1,n)\bigr)$
    \nonum\State where $\circ_i\in\set{+,-,\times,\div}$ are chosen randomly
\EndFunc
\ealgorithm
\medskip

\noindent We then run ILang code of the form \ttt{let x = <expr>;} where \ttt{<expr>} is generated by the above algorithm.
We measure how long it takes to run this code five times with expressions generated by $\hbox{\tencsc Generate-Expression}(n,n,100)$ as $n$ varies (figure \ref{fig:expr1}) and
expressions generated by $\hbox{\tencsc Generate-Expression}(n,1,100)$ as $n$ varies (figure \ref{fig:expr2}).

\begin{figure}

    \centerline{\includegraphics[width=\hsize]{../Docs/Images/expr-n-n.png}}
    \caption{Time to compute $\hbox{\tencsc Generate-Expression}(n,n)$}
    \label{fig:expr1}
    \medskip
    \centerline{\includegraphics[width=\hsize]{../Docs/Images/expr-n-1.png}}
    \caption{Time to compute $\hbox{\tencsc Generate-Expression}(n,1)$}
    \label{fig:expr2}

\end{figure}

\subsection{Fibonacci}

The fibonacci sequence is a linear recurrence defined by $F_n=F_{n-1}+F_{n-2}$ for $n>1$ and $F_1=F_0=1$.
We wrote a script to compute the $n$th fibonacci number recursively in ILang:

\begin{lstlisting}[language=Caml, frame=single]
fun fib (x) {
    if (x < 2) {
        1
    }{
        (fib (x-1)) + (fib (x-2))
    }
}
let x = (fib n);
_prim_print x
\end{lstlisting}

\noindent Running each implementation 5 times for each $x$, we get the following graph in figure \ref{fig:fib} (as $x$ varies):

\begin{figure}

    \centerline{\includegraphics[width=\hsize]{../Docs/Images/fib.png}}
    \caption{Time to compute $\hbox{\tt fib}(x)$}
    \label{fig:fib}

\end{figure}

Our implementation takes approximately $\sim ab^x$ seconds to run where $a=0.000138585, b=1.64685$, and the menhir-based interpreter takes $\sim ab^x$ seconds where $a=0.00000362553, b=1.5809$.

\section{Conclusion}

We can see that iterative reduction is significantly slower than the menhir-based interpreter.
This can be for various reasons:
\begin{enumerate}

    \item When handling function calls, iterative reduction simply re-reduces the string in the definition of the function.
        This requires it to parse and interpret the function again.
        But classically, since the function definition has already been parsed and a parse tree created, further parsing of the function is not created.
        This means that classical methods handle function calls better than iterative reduction, but on the other hand iterative reduction can handle macro-like programming better.
        For example, if one were to change the state to map \ttt( to $\Lbrace$, the menhir-based interpreter would not be able to reparse the function to reinterpret \ttt(.
        But this naturally happens with iterative reduction, for better or worse.
        \gobble)\gobble)

    \item The standard methods of parsing code are well-studied and optimized.
        Menhir does not naively parse code, it is an optimized tool.
        Thus comparing a naive implementation of iterative reduction to menhir is not a fair comparison.
\end{enumerate}

\section{$\beta$-Reducible Languages}

In this section we will try to understand better the class of languages which can be parsed using $\beta$-reduction.
The definition of $\beta$-reduction in this section will differ slightly from the remainder of this paper, but core ideas will be preserved.
We will construct a hierarchy of $\beta$-reducible languages, which we will compare with the Chomsky Hierarchy.

\subsection{$\beta$-Reducible Languages}

The simplest class in our hierarchy will be $\beta$-reducible languages, the class of which we will denote by \BR.
Define a \BR-schema to be a tuple $B=(\Sigma,\Gamma,\square,\blacksquare,\bullet,s,\hb)$ where
\begin{enumerate}
    \item $\Sigma$ is a finite alphabet of terminals,
    \item $\Gamma$ is a finite alphabet of non-terminals (generally $\Sigma$ and $\Gamma$ are disjoint, but we don't require this),
    \item $\square,\blacksquare$ are symbols not in $\Sigma,\Gamma$,
    \item $\bullet$ is a symbol (which may be in $\Sigma,\Gamma$) or the empty word,
    \item $s$ is a state, which is a map $\Sigma\to\Gamma$,
    \item $\hb$ is an initial $\beta$-reducer, which is a partial function $\hb\colon\Gamma\times(\Gamma\cup\set{\epsilon,\blacksquare})\partial\Gamma\cup\set{\epsilon,\bullet}$.
\end{enumerate}
Given a \BR-schema, we define a pre-$\beta$-reducer to be a function $\beta'\colon(\Gamma\cup\set\bullet)^*\longto(\Gamma\cup\set\bullet)^*$ as follows: given a string $\xi\in(\Gamma\cup\set\bullet)^*$ we define $\beta'(\xi)$ as follows:
\begin{enumerate}
    \item If $\xi=\bullet$, then $\beta'(\xi)=\xi$
    \item If $\xi=\sigma\in\Gamma$, then $\beta'(\xi)=\hb(\sigma,\blacksquare)$ if it is defined, and $\sigma$ otherwise,
    \item If $\xi=\sigma_1\sigma_2\xi'$, then
        \begin{enumerate}
            \item $\beta'(\xi)=\hb(\sigma_1,\sigma_2)\xi'$ if it is defined, otherwise
            \item $\beta'(\xi)=\hb(\sigma_1,\epsilon)\sigma_2\xi'$ if it is defined, otherwise
            \item $\beta'(\xi)=\sigma_1\beta'(\sigma_2\xi')$.
        \end{enumerate}
\end{enumerate}
And we define a $\beta$-reducer to be a function $\beta\colon(\Gamma\cup\set\bullet)^*\longto(\Gamma\cup\set\bullet)^*$ as follows: given $\xi\in(\Gamma\cup\set\bullet)^*$ we define $\beta(\xi)$ as follows:
\begin{enumerate}
    \item if $\xi=\epsilon$ and $\hb(\square,\blacksquare)=\tau$ is defined then $\beta(\xi)=\tau$,
    \item if $\xi=\sigma\xi'$ and $\hb(\square,\sigma)=\tau$ is defined then $\beta(\xi)=\tau\xi'$,
    \item otherwise $\beta(\xi)=\beta'(\xi)$.
\end{enumerate}
Then we define $\beta^*(\xi)$ to be the fixed point of successive applications of $\beta$ to $\xi$, i.e. $\beta^*(\xi)=\beta^n(\xi)$ where $\beta^n(\xi)=\beta^{n+1}(\xi)$.
For a word $w=\sigma_1\cdots\sigma_n=\in\Sigma^*$, we define $s(w)=s(\sigma_1)\cdots s(\sigma_n)\in\Gamma^*$.
The language \textit{generated} (or \textit{accepted}) by a \BR-schema $B$ is defined to be all the words $w\in\Sigma^*$ such that $\beta^*(s(w))=\bullet$.

Finally, let $\sigma\in\Gamma$: define the set $C(\sigma)=\bigcup_{n\geq1}C_n(\sigma)$ where $C_0(\sigma)=\set\sigma$ and $C_{n+1}(\sigma)=\set{\hb(\tau,\epsilon),\hb(\tau,\square)}[\tau\in C_n(\sigma)]$.
Call a \BR-schema \textit{valid} if $\sigma\notin C(\sigma)$ for all $\sigma\in\Gamma$ and $\hb(\square,\blacksquare)$ is either undefined or $\bullet$.
A $\beta$-reducible language is one generated by a valid \BR-schema; the class of all $\beta$-reducible languages is denoted \BR.
The reason for requiring a \BR-schema to be valid is to ensure that the $\beta$-reducer halts.
Otherwise, suppose $\sigma\in C(\sigma)$, so we could have that $\hb(\sigma,\square)=\sigma$ for example, and then $\beta$ would never halt on the string $\sigma$.
Validity is not a strong requirement.

According to theorem \ref{thrm:complexity}, all $\beta$-reducible languages can be reduced by their $\beta$-reducer in $O(n)$ time.

For example, $\set{a^nb^n}[n\geq1]$ is in \BR.
We define $B=(\Sigma,\Gamma,s,\hb)$ as follows:
\begin{enumerate}
    \item $\Sigma=\set{a,b}$,
    \item $\Gamma=\set{S_a,S_b,S_{ab},S_{aab}}$,
    \item $s(a)=S_a$ and $s(b)=S_b$,
    \item $\hb$ is defined by the rules:
        \[ S_a,S_b\to S_{ab},\quad S_a,S_{ab}\to S_{aab},\quad S_{aab},S_b=S_{ab},\quad S_{ab},\blacksquare\to\bullet \]
\end{enumerate}
Indeed, a word of the form $a\cdots ab\cdots b$ will be mapped to $S_a\cdots S_aS_b\cdots S_b$, which will then be reduced to $S_a\cdots S_aS_{ab}S_b\cdots S_b\to S_a\cdots S_{aab}S_b\cdots S_b\to S_a\cdots S_{ab}\cdots S_b$, and so on until $S_{ab}$, which is then reduced
to $\bullet$.

\begin{definition}

    A \emph{finite state machine} is a tuple $A=(\Sigma,Q,q_0,F,\delta)$ where
    \begin{enumerate}
        \item $\Sigma$ is an alphabet,
        \item $Q$ is a set of states,
        \item $q_0\in Q$ is the initial state,
        \item $F\subseteq Q$ is the set of final states,
        \item $\delta\colon Q\times\Sigma\to Q$ is the \emph{transition function}.
    \end{enumerate}
    We define $\delta^*\colon Q\times\Sigma^*\longto Q$ as follows:
    \[ \delta^*(q,\epsilon)=q,\qquad \delta^*(q,\sigma\xi)=\delta^*(\delta(q,\sigma),\xi) \]
    And then we define the \emph{language} of $A$ to be
    \[ \c L(A) = \set{\xi\in\Sigma^*}[\delta^*(q_0,\xi)\in F] \]

    A language $L$ is \emph{regular} if there exists a finite state machine $A$ such that $\c L(A)=L$.
    The class of all regular languages is denoted \REG.

\end{definition}

\begin{theorem}

    Every regular language is $\beta$-reducible.

\end{theorem}

\begin{proof}

    Let $A=(\Sigma,Q,q_0,F,\delta)$ be a finite state machine.
    We define a \BR-schema $B=(\Sigma,\Gamma,q_0,\blacksquare,\bullet,s,\hb)$ as follows: $\Gamma=\Sigma\cup Q$, $s\colon\sigma\mapsto\sigma$, and for $q\in Q$ and $\sigma\in\Sigma$ we define $\hb(q,\sigma)=\delta(q,\sigma)$.
    And for $q\in F$ we define $\hb(q,\blacksquare)=\bullet$.

    Simple induction will show that $q\xi\to^*\delta^*(q,\xi)$ (where $\xi\to^*\xi'$ means that $\beta^n(\xi)=\xi'$ for some $n$).
    Indeed $\delta^*(q,\epsilon)=q$ and $q\to^*q$, and $q\sigma\xi\to\hb(q,\sigma)\xi=\delta(q,\sigma)\xi$ and by induction $\to^*\delta^*(\delta(q,\sigma),\xi)=\delta^*(q,\sigma\xi)$ as required.
    From this it follows easily that (because $\square=q_0$) $\xi\to^*\delta^*(\xi)$ and thus $\beta^*(\xi)=\bullet$ if and only if $\delta^*(\xi)\in F$, if and only if $\xi\in\c L(A)$.
    Thus $\c L(A)=\c L(B)$ as required.
    \qed

\end{proof}

So we have shown that the class of regular languages, \REG, is a proper subclass of \BR{} (since $\set{a^nb^n}[n\geq1]$ is in \BR{} yet not regular).
The question then becomes, what is the relationship between \BR{} and the class of context-free languages \CFL{}, or the class of deterministic context-free languages \DCFL?

\ari{I hope to prove or disprove this (hopefully finding some analogy for the pumping lemma for \BR)}
We conjecture that $\DCFL=\BR$.
For example, we are unsure but believe that the language of even palindromes, $\set{ww^r}[w\in\set{a,b}^+]$, is not \BR.

\ari{The following section is just me writing down some ideas, far from finished}

\subsection{Multi-$\beta$-Reducible Languages}

For $n\geq1$, a $\BR(n)$-schema is a tuple $(\Sigma,\Gamma,\square,\blacksquare,\bullet,s,\set{\hb_i}_{i=0}^{n-1})$ where $\Sigma,\Gamma,\square,\blacksquare,\bullet,s$ are as before and now
\[ \hb_i\colon\Gamma\times(\Gamma\cup\set{\epsilon,\square})\partial(\Gamma\cup\set{\epsilon,\bullet})\times\set{0,\dots,n-1} \]
For each $i\in\set{0,\dots,n-1}$ we define $\beta_i$ as before, but instead of returning the string it also returns the index returned by the reduction.
$\beta^*$ will then start using $\beta_0$, and then when the current $\beta_i$ returns $j$, it switches to $\beta_j$.

We define \MBR{} to be $\MBR=\bigcup_{n\geq1}\BR(n)$.

This is (we believe) stronger than \BR: $\set{ww^r}[w\in\set{a,b}^+]$ is \MBR.
We construct a $\BR(5)$-schema as follows:
\[ B = \parens{\set{a,b},\set{A,B,A',B'},\square,\blacksquare,\bullet,[a\to A,b\to B],\set{\hb_0,\hb_1,\hb_2,\hb_3,\hb_4}} \]
Where we have the reduction rules:
\begin{align*}
    \hb_0\colon\quad& \square,A\to A',1\\
        & \square,B\to B',3\\
    \hb_1\colon\quad& A,\square\to A',2\\
    \hb_2\colon\quad& A',A'\to\bullet,2\\
        &A',\epsilon\to\epsilon,2\\
        &A',\square\to A',0\\
    \hb_3\colon\quad& B,\square\to B',2\\
    \hb_4\colon\quad& B',B'\to\bullet,2\\
        &B',\epsilon\to\epsilon,2\\
        &B',\square\to B',0\\
\end{align*}
Intuitively, $\hb_0$ detects the first character and ``tags'' it, then $\hb_1$ or $\hb_3$ ``tag'' the end character if it is the same as the beginning character.
$\hb_2$ and $\hb_4$ ``clean up'' the tags: if the two tagged characters are next to each other, then we can try and accept the word.
Otherwise delete them both.

For the language of palindromes $\set{w\in\set{a,b}^*}[w=w^r]$ we can define a $\BR(3)$-schema where $\bullet=\epsilon$ and
\begin{align*}
    \hb_0\colon\quad& \square,A\to\epsilon,1\\
        & \square,B\to\epsilon,2\\
    \hb_1\colon\quad& A,\blacksquare\to\epsilon,0\\
    \hb_2\colon\quad& B,\blacksquare\to\epsilon,0\\
\end{align*}

But \MBR{} is not contained in \CFL{}: $\set{a^nb^nc^n}[n\geq1]\in\MBR$.
Indeed, we can construct an \MBR-schema as follows:
\[ B = \parens{\set{a,b,c},\set{A,B,C,X},[a\to A,b\to B,c\to C],\set{\hb_0,\hb_1,\hb_2,\hb_3}} \]
And we have the reduction rules:
\begin{align*}
    \hb_0\colon\quad& B,A\to X,0\\
        &C,B\to X,0\\
        &C,\square\to C,1\\
    \hb_1\colon\quad& A,\epsilon\to\epsilon,2\\
    \hb_2\colon\quad& B,\epsilon\to\epsilon,3\\
    \hb_3\colon\quad& C,\square\to\bullet,3\\
        &C,\epsilon\to\epsilon,1
\end{align*}
Intuitively, $\hb_0$ checks that $A$ comes before $B$ which comes before $C$ (as otherwise it places in an $X$, which is never reduced).
Then $\hb_1$ matches a single $A$, then calls $\hb_2$ to match a single $B$, which calls $\hb_3$ to match a single $C$.

\bibliographystyle{abbrv}
\bibliography{paper-bib}


\end{document}

